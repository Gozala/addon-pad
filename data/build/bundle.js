(function(){var require = function (file, cwd, parent) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod(parent || null);
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname, module_);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function (parent) {
            module_.parent = parent;
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/codemirror-embed/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/codemirror-embed/package.json"
));

require.define("/node_modules/codemirror-embed/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\n/*global CodeMirror */\nrequire(\"codemirror/lib/codemirror\")\nmodule.exports = CodeMirror\n\n//@ sourceURL=/node_modules/codemirror-embed/index.js"
));

require.define("/node_modules/codemirror/lib/codemirror.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// All functions that need access to the editor's state live inside\n// the CodeMirror function. Below that, at the bottom of the file,\n// some utilities are defined.\n\n// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  \"use strict\";\n  // This is the function that produces an editor instance. Its\n  // closure is used to store the editor state.\n  function CodeMirror(place, givenOptions) {\n    // Determine effective options based on given values and defaults.\n    var options = {}, defaults = CodeMirror.defaults;\n    for (var opt in defaults)\n      if (defaults.hasOwnProperty(opt))\n        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];\n\n    var input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em\");\n    input.setAttribute(\"wrap\", \"off\"); input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\");\n    // Wraps and hides input textarea\n    var inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The empty scrollbar content, used solely for managing the scrollbar thumb.\n    var scrollbarInner = elt(\"div\", null, \"CodeMirror-scrollbar-inner\");\n    // The vertical scrollbar. Horizontal scrolling is handled by the scroller itself.\n    var scrollbar = elt(\"div\", [scrollbarInner], \"CodeMirror-scrollbar\");\n    // DIVs containing the selection and the actual code\n    var lineDiv = elt(\"div\"), selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: -1\");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    var cursor = elt(\"pre\", \"\\u00a0\", \"CodeMirror-cursor\"), widthForcer = elt(\"pre\", \"\\u00a0\", \"CodeMirror-cursor\", \"visibility: hidden\");\n    // Used to measure text size\n    var measure = elt(\"div\", null, null, \"position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden;\");\n    var lineSpace = elt(\"div\", [measure, cursor, widthForcer, selectionDiv, lineDiv], null, \"position: relative; z-index: 0\");\n    var gutterText = elt(\"div\", null, \"CodeMirror-gutter-text\"), gutter = elt(\"div\", [gutterText], \"CodeMirror-gutter\");\n    // Moved around its parent to cover visible view\n    var mover = elt(\"div\", [gutter, elt(\"div\", [lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the text, causes scrolling\n    var sizer = elt(\"div\", [mover], null, \"position: relative\");\n    // Provides scrolling\n    var scroller = elt(\"div\", [sizer], \"CodeMirror-scroll\");\n    scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    var wrapper = elt(\"div\", [inputDiv, scrollbar, scroller], \"CodeMirror\" + (options.lineWrapping ? \" CodeMirror-wrap\" : \"\"));\n    if (place.appendChild) place.appendChild(wrapper); else place(wrapper);\n\n    themeChanged(); keyMapChanged();\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) scroller.draggable = true;\n    lineSpace.style.outline = \"none\";\n    if (options.tabindex != null) input.tabIndex = options.tabindex;\n    if (options.autofocus) focusInput();\n    if (!options.gutter && !options.lineNumbers) gutter.style.display = \"none\";\n    // Needed to handle Tab key in KHTML\n    if (khtml) inputDiv.style.height = \"1px\", inputDiv.style.position = \"absolute\";\n\n    // Check for OS X >= 10.7. This has transparent scrollbars, so the\n    // overlaying of one scrollbar with another won't work. This is a\n    // temporary hack to simply turn off the overlay scrollbar. See\n    // issue #727.\n    if (mac_geLion) { scrollbar.style.zIndex = -2; scrollbar.style.visibility = \"hidden\"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) scrollbar.style.minWidth = \"18px\";\n\n    // Delayed object wrap timeouts, making sure only one is active. blinker holds an interval.\n    var poll = new Delayed(), highlight = new Delayed(), blinker;\n\n    // mode holds a mode API object. doc is the tree of Line objects,\n    // frontier is the point up to which the content has been parsed,\n    // and history the undo history (instance of History constructor).\n    var mode, doc = new BranchChunk([new LeafChunk([new Line(\"\")])]), frontier = 0, focused;\n    loadMode();\n    // The selection. These are always maintained to point at valid\n    // positions. Inverted is used to remember that the user is\n    // selecting bottom-to-top.\n    var sel = {from: {line: 0, ch: 0}, to: {line: 0, ch: 0}, inverted: false};\n    // Selection-related flags. shiftSelecting obviously tracks\n    // whether the user is holding shift.\n    var shiftSelecting, lastClick, lastDoubleClick, lastScrollTop = 0, draggingText,\n        overwrite = false, suppressEdits = false;\n    // Variables used by startOperation/endOperation to track what\n    // happened during the operation.\n    var updateInput, userSelChange, changes, textChanged, selectionChanged,\n        gutterDirty, callbacks;\n    // Current visible range (may be bigger than the view window).\n    var displayOffset = 0, showingFrom = 0, showingTo = 0, lastSizeC = 0;\n    // bracketHighlighted is used to remember that a bracket has been\n    // marked.\n    var bracketHighlighted;\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    var maxLine = getLine(0), updateMaxLine = false, maxLineChanged = true;\n    var pollingFast = false; // Ensures slowPoll doesn't cancel fastPoll\n    var goalColumn = null;\n\n    // Initialize the content.\n    operation(function(){setValue(options.value || \"\"); updateInput = false;})();\n    var history = new History();\n\n    // Register our event handlers.\n    connect(scroller, \"mousedown\", operation(onMouseDown));\n    connect(scroller, \"dblclick\", operation(onDoubleClick));\n    connect(lineSpace, \"selectstart\", e_preventDefault);\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!gecko) connect(scroller, \"contextmenu\", onContextMenu);\n    connect(scroller, \"scroll\", onScrollMain);\n    connect(scrollbar, \"scroll\", onScrollBar);\n    connect(scrollbar, \"mousedown\", function() {if (focused) setTimeout(focusInput, 0);});\n    var resizeHandler = connect(window, \"resize\", function() {\n      if (wrapper.parentNode) updateDisplay(true);\n      else resizeHandler();\n    }, true);\n    connect(input, \"keyup\", operation(onKeyUp));\n    connect(input, \"input\", fastPoll);\n    connect(input, \"keydown\", operation(onKeyDown));\n    connect(input, \"keypress\", operation(onKeyPress));\n    connect(input, \"focus\", onFocus);\n    connect(input, \"blur\", onBlur);\n\n    function drag_(e) {\n      if (options.onDragEvent && options.onDragEvent(instance, addStop(e))) return;\n      e_stop(e);\n    }\n    if (options.dragDrop) {\n      connect(scroller, \"dragstart\", onDragStart);\n      connect(scroller, \"dragenter\", drag_);\n      connect(scroller, \"dragover\", drag_);\n      connect(scroller, \"drop\", operation(onDrop));\n    }\n    connect(scroller, \"paste\", function(){focusInput(); fastPoll();});\n    connect(input, \"paste\", fastPoll);\n    connect(input, \"cut\", operation(function(){\n      if (!options.readOnly) replaceSelection(\"\");\n    }));\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) connect(sizer, \"mouseup\", function() {\n        if (document.activeElement == input) input.blur();\n        focusInput();\n    });\n\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == input); } catch(e) { }\n    if (hasFocus || options.autofocus) setTimeout(onFocus, 20);\n    else onBlur();\n\n    function isLine(l) {return l >= 0 && l < doc.size;}\n    // The instance object that we'll return. Mostly calls out to\n    // local functions in the CodeMirror function. Some do some extra\n    // range checking and/or clipping. operation is used to wrap the\n    // call so that changes it makes are tracked, and the display is\n    // updated afterwards.\n    var instance = wrapper.CodeMirror = {\n      getValue: getValue,\n      setValue: operation(setValue),\n      getSelection: getSelection,\n      replaceSelection: operation(replaceSelection),\n      focus: function(){window.focus(); focusInput(); onFocus(); fastPoll();},\n      setOption: function(option, value) {\n        var oldVal = options[option];\n        options[option] = value;\n        if (option == \"mode\" || option == \"indentUnit\") loadMode();\n        else if (option == \"readOnly\" && value == \"nocursor\") {onBlur(); input.blur();}\n        else if (option == \"readOnly\" && !value) {resetInput(true);}\n        else if (option == \"theme\") themeChanged();\n        else if (option == \"lineWrapping\" && oldVal != value) operation(wrappingChanged)();\n        else if (option == \"tabSize\") updateDisplay(true);\n        else if (option == \"keyMap\") keyMapChanged();\n        if (option == \"lineNumbers\" || option == \"gutter\" || option == \"firstLineNumber\" ||\n            option == \"theme\" || option == \"lineNumberFormatter\") {\n          gutterChanged();\n          updateDisplay(true);\n        }\n      },\n      getOption: function(option) {return options[option];},\n      undo: operation(undo),\n      redo: operation(redo),\n      indentLine: operation(function(n, dir) {\n        if (typeof dir != \"string\") {\n          if (dir == null) dir = options.smartIndent ? \"smart\" : \"prev\";\n          else dir = dir ? \"add\" : \"subtract\";\n        }\n        if (isLine(n)) indentLine(n, dir);\n      }),\n      indentSelection: operation(indentSelected),\n      historySize: function() {return {undo: history.done.length, redo: history.undone.length};},\n      clearHistory: function() {history = new History();},\n      setHistory: function(histData) {\n        history = new History();\n        history.done = histData.done;\n        history.undone = histData.undone;\n      },\n      getHistory: function() {\n        history.time = 0;\n        return {done: history.done.concat([]), undone: history.undone.concat([])};\n      },\n      matchBrackets: operation(function(){matchBrackets(true);}),\n      getTokenAt: operation(function(pos) {\n        pos = clipPos(pos);\n        return getLine(pos.line).getTokenAt(mode, getStateBefore(pos.line), options.tabSize, pos.ch);\n      }),\n      getStateAfter: function(line) {\n        line = clipLine(line == null ? doc.size - 1: line);\n        return getStateBefore(line + 1);\n      },\n      cursorCoords: function(start, mode) {\n        if (start == null) start = sel.inverted;\n        return this.charCoords(start ? sel.from : sel.to, mode);\n      },\n      charCoords: function(pos, mode) {\n        pos = clipPos(pos);\n        if (mode == \"local\") return localCoords(pos, false);\n        if (mode == \"div\") return localCoords(pos, true);\n        return pageCoords(pos);\n      },\n      coordsChar: function(coords) {\n        var off = eltOffset(lineSpace);\n        return coordsChar(coords.x - off.left, coords.y - off.top);\n      },\n      markText: operation(markText),\n      setBookmark: setBookmark,\n      findMarksAt: findMarksAt,\n      setMarker: operation(addGutterMarker),\n      clearMarker: operation(removeGutterMarker),\n      setLineClass: operation(setLineClass),\n      hideLine: operation(function(h) {return setLineHidden(h, true);}),\n      showLine: operation(function(h) {return setLineHidden(h, false);}),\n      onDeleteLine: function(line, f) {\n        if (typeof line == \"number\") {\n          if (!isLine(line)) return null;\n          line = getLine(line);\n        }\n        (line.handlers || (line.handlers = [])).push(f);\n        return line;\n      },\n      lineInfo: lineInfo,\n      getViewport: function() { return {from: showingFrom, to: showingTo};},\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        pos = localCoords(clipPos(pos));\n        var top = pos.yBot, left = pos.x;\n        node.style.position = \"absolute\";\n        sizer.appendChild(node);\n        if (vert == \"over\") top = pos.y;\n        else if (vert == \"near\") {\n          var vspace = Math.max(scroller.offsetHeight, doc.height * textHeight()),\n              hspace = Math.max(sizer.clientWidth, lineSpace.clientWidth) - paddingLeft();\n          if (pos.yBot + node.offsetHeight > vspace && pos.y > node.offsetHeight)\n            top = pos.y - node.offsetHeight;\n          if (left + node.offsetWidth > hspace)\n            left = hspace - node.offsetWidth;\n        }\n        node.style.top = (top + paddingTop()) + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") left = 0;\n          else if (horiz == \"middle\") left = (sizer.clientWidth - node.offsetWidth) / 2;\n          node.style.left = (left + paddingLeft()) + \"px\";\n        }\n        if (scroll)\n          scrollIntoView(left, top, left + node.offsetWidth, top + node.offsetHeight);\n      },\n\n      lineCount: function() {return doc.size;},\n      clipPos: clipPos,\n      getCursor: function(start) {\n        if (start == null) start = sel.inverted;\n        return copyPos(start ? sel.from : sel.to);\n      },\n      somethingSelected: function() {return !posEq(sel.from, sel.to);},\n      setCursor: operation(function(line, ch, user) {\n        if (ch == null && typeof line.line == \"number\") setCursor(line.line, line.ch, user);\n        else setCursor(line, ch, user);\n      }),\n      setSelection: operation(function(from, to, user) {\n        (user ? setSelectionUser : setSelection)(clipPos(from), clipPos(to || from));\n      }),\n      getLine: function(line) {if (isLine(line)) return getLine(line).text;},\n      getLineHandle: function(line) {if (isLine(line)) return getLine(line);},\n      setLine: operation(function(line, text) {\n        if (isLine(line)) replaceRange(text, {line: line, ch: 0}, {line: line, ch: getLine(line).text.length});\n      }),\n      removeLine: operation(function(line) {\n        if (isLine(line)) replaceRange(\"\", {line: line, ch: 0}, clipPos({line: line+1, ch: 0}));\n      }),\n      replaceRange: operation(replaceRange),\n      getRange: function(from, to, lineSep) {return getRange(clipPos(from), clipPos(to), lineSep);},\n\n      triggerOnKeyDown: operation(onKeyDown),\n      execCommand: function(cmd) {return commands[cmd](instance);},\n      // Stuff used by commands, probably not much use to outside code.\n      moveH: operation(moveH),\n      deleteH: operation(deleteH),\n      moveV: operation(moveV),\n      toggleOverwrite: function() {\n        if(overwrite){\n          overwrite = false;\n          cursor.className = cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n        } else {\n          overwrite = true;\n          cursor.className += \" CodeMirror-overwrite\";\n        }\n      },\n\n      posFromIndex: function(off) {\n        var lineNo = 0, ch;\n        doc.iter(0, doc.size, function(line) {\n          var sz = line.text.length + 1;\n          if (sz > off) { ch = off; return true; }\n          off -= sz;\n          ++lineNo;\n        });\n        return clipPos({line: lineNo, ch: ch});\n      },\n      indexFromPos: function (coords) {\n        if (coords.line < 0 || coords.ch < 0) return 0;\n        var index = coords.ch;\n        doc.iter(0, coords.line, function (line) {\n          index += line.text.length + 1;\n        });\n        return index;\n      },\n      scrollTo: function(x, y) {\n        if (x != null) scroller.scrollLeft = x;\n        if (y != null) scrollbar.scrollTop = scroller.scrollTop = y;\n        updateDisplay([]);\n      },\n      getScrollInfo: function() {\n        return {x: scroller.scrollLeft, y: scrollbar.scrollTop,\n                height: scrollbar.scrollHeight, width: scroller.scrollWidth};\n      },\n      setSize: function(width, height) {\n        function interpret(val) {\n          val = String(val);\n          return /^\\d+$/.test(val) ? val + \"px\" : val;\n        }\n        if (width != null) wrapper.style.width = interpret(width);\n        if (height != null) scroller.style.height = interpret(height);\n        instance.refresh();\n      },\n\n      operation: function(f){return operation(f)();},\n      compoundChange: function(f){return compoundChange(f);},\n      refresh: function(){\n        updateDisplay(true, null, lastScrollTop);\n        if (scrollbar.scrollHeight > lastScrollTop)\n          scrollbar.scrollTop = lastScrollTop;\n      },\n      getInputField: function(){return input;},\n      getWrapperElement: function(){return wrapper;},\n      getScrollerElement: function(){return scroller;},\n      getGutterElement: function(){return gutter;}\n    };\n\n    function getLine(n) { return getLineAt(doc, n); }\n    function updateLineHeight(line, height) {\n      gutterDirty = true;\n      var diff = height - line.height;\n      for (var n = line; n; n = n.parent) n.height += diff;\n    }\n\n    function lineContent(line, wrapAt) {\n      if (!line.styles)\n        line.highlight(mode, line.stateAfter = getStateBefore(lineNo(line)), options.tabSize);\n      return line.getContent(options.tabSize, wrapAt, options.lineWrapping);\n    }\n\n    function setValue(code) {\n      var top = {line: 0, ch: 0};\n      updateLines(top, {line: doc.size - 1, ch: getLine(doc.size-1).text.length},\n                  splitLines(code), top, top);\n      updateInput = true;\n    }\n    function getValue(lineSep) {\n      var text = [];\n      doc.iter(0, doc.size, function(line) { text.push(line.text); });\n      return text.join(lineSep || \"\\n\");\n    }\n\n    function onScrollBar(e) {\n      if (scrollbar.scrollTop != lastScrollTop) {\n        lastScrollTop = scroller.scrollTop = scrollbar.scrollTop;\n        updateDisplay([]);\n      }\n    }\n\n    function onScrollMain(e) {\n      if (options.fixedGutter && gutter.style.left != scroller.scrollLeft + \"px\")\n        gutter.style.left = scroller.scrollLeft + \"px\";\n      if (scroller.scrollTop != lastScrollTop) {\n        lastScrollTop = scroller.scrollTop;\n        if (scrollbar.scrollTop != lastScrollTop)\n          scrollbar.scrollTop = lastScrollTop;\n        updateDisplay([]);\n      }\n      if (options.onScroll) options.onScroll(instance);\n    }\n\n    function onMouseDown(e) {\n      setShift(e_prop(e, \"shiftKey\"));\n      // Check whether this is a click in a widget\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == sizer && n != mover) return;\n\n      // See if this is a click in the gutter\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == gutterText) {\n          if (options.onGutterClick)\n            options.onGutterClick(instance, indexOf(gutterText.childNodes, n) + showingFrom, e);\n          return e_preventDefault(e);\n        }\n\n      var start = posFromMouse(e);\n\n      switch (e_button(e)) {\n      case 3:\n        if (gecko) onContextMenu(e);\n        return;\n      case 2:\n        if (start) setCursor(start.line, start.ch, true);\n        setTimeout(focusInput, 20);\n        e_preventDefault(e);\n        return;\n      }\n      // For button 1, if it was clicked inside the editor\n      // (posFromMouse returning non-null), we have to adjust the\n      // selection.\n      if (!start) {if (e_target(e) == scroller) e_preventDefault(e); return;}\n\n      if (!focused) onFocus();\n\n      var now = +new Date, type = \"single\";\n      if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n        type = \"triple\";\n        e_preventDefault(e);\n        setTimeout(focusInput, 20);\n        selectLine(start.line);\n      } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n        type = \"double\";\n        lastDoubleClick = {time: now, pos: start};\n        e_preventDefault(e);\n        var word = findWordAt(start);\n        setSelectionUser(word.from, word.to);\n      } else { lastClick = {time: now, pos: start}; }\n\n      function dragEnd(e2) {\n        if (webkit) scroller.draggable = false;\n        draggingText = false;\n        up(); drop();\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          setCursor(start.line, start.ch, true);\n          focusInput();\n        }\n      }\n      var last = start, going;\n      if (options.dragDrop && dragAndDrop && !options.readOnly && !posEq(sel.from, sel.to) &&\n          !posLess(start, sel.from) && !posLess(sel.to, start) && type == \"single\") {\n        // Let the drag handler handle this.\n        if (webkit) scroller.draggable = true;\n        var up = connect(document, \"mouseup\", operation(dragEnd), true);\n        var drop = connect(scroller, \"drop\", operation(dragEnd), true);\n        draggingText = true;\n        // IE's approach to draggable\n        if (scroller.dragDrop) scroller.dragDrop();\n        return;\n      }\n      e_preventDefault(e);\n      if (type == \"single\") setCursor(start.line, start.ch, true);\n\n      var startstart = sel.from, startend = sel.to;\n\n      function doSelect(cur) {\n        if (type == \"single\") {\n          setSelectionUser(start, cur);\n        } else if (type == \"double\") {\n          var word = findWordAt(cur);\n          if (posLess(cur, startstart)) setSelectionUser(word.from, startend);\n          else setSelectionUser(startstart, word.to);\n        } else if (type == \"triple\") {\n          if (posLess(cur, startstart)) setSelectionUser(startend, clipPos({line: cur.line, ch: 0}));\n          else setSelectionUser(startstart, clipPos({line: cur.line + 1, ch: 0}));\n        }\n      }\n\n      function extend(e) {\n        var cur = posFromMouse(e, true);\n        if (cur && !posEq(cur, last)) {\n          if (!focused) onFocus();\n          last = cur;\n          doSelect(cur);\n          updateInput = false;\n          var visible = visibleLines();\n          if (cur.line >= visible.to || cur.line < visible.from)\n            going = setTimeout(operation(function(){extend(e);}), 150);\n        }\n      }\n\n      function done(e) {\n        clearTimeout(going);\n        var cur = posFromMouse(e);\n        if (cur) doSelect(cur);\n        e_preventDefault(e);\n        focusInput();\n        updateInput = true;\n        move(); up();\n      }\n      var move = connect(document, \"mousemove\", operation(function(e) {\n        clearTimeout(going);\n        e_preventDefault(e);\n        if (!ie && !e_button(e)) done(e);\n        else extend(e);\n      }), true);\n      var up = connect(document, \"mouseup\", operation(done), true);\n    }\n    function onDoubleClick(e) {\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == gutterText) return e_preventDefault(e);\n      e_preventDefault(e);\n    }\n    function onDrop(e) {\n      if (options.onDragEvent && options.onDragEvent(instance, addStop(e))) return;\n      e_preventDefault(e);\n      var pos = posFromMouse(e, true), files = e.dataTransfer.files;\n      if (!pos || options.readOnly) return;\n      if (files && files.length && window.FileReader && window.File) {\n        var n = files.length, text = Array(n), read = 0;\n        var loadFile = function(file, i) {\n          var reader = new FileReader;\n          reader.onload = function() {\n            text[i] = reader.result;\n            if (++read == n) {\n              pos = clipPos(pos);\n              operation(function() {\n                var end = replaceRange(text.join(\"\"), pos, pos);\n                setSelectionUser(pos, end);\n              })();\n            }\n          };\n          reader.readAsText(file);\n        };\n        for (var i = 0; i < n; ++i) loadFile(files[i], i);\n      } else {\n        // Don't do a replace if the drop happened inside of the selected text.\n        if (draggingText && !(posLess(pos, sel.from) || posLess(sel.to, pos))) return;\n        try {\n          var text = e.dataTransfer.getData(\"Text\");\n          if (text) {\n            compoundChange(function() {\n              var curFrom = sel.from, curTo = sel.to;\n              setSelectionUser(pos, pos);\n              if (draggingText) replaceRange(\"\", curFrom, curTo);\n              replaceSelection(text);\n              focusInput();\n            });\n          }\n        }\n        catch(e){}\n      }\n    }\n    function onDragStart(e) {\n      var txt = getSelection();\n      e.dataTransfer.setData(\"Text\", txt);\n\n      // Use dummy image instead of default browsers image.\n      if (e.dataTransfer.setDragImage)\n        e.dataTransfer.setDragImage(elt('img'), 0, 0);\n    }\n\n    function doHandleBinding(bound, dropShift) {\n      if (typeof bound == \"string\") {\n        bound = commands[bound];\n        if (!bound) return false;\n      }\n      var prevShift = shiftSelecting;\n      try {\n        if (options.readOnly) suppressEdits = true;\n        if (dropShift) shiftSelecting = null;\n        bound(instance);\n      } catch(e) {\n        if (e != Pass) throw e;\n        return false;\n      } finally {\n        shiftSelecting = prevShift;\n        suppressEdits = false;\n      }\n      return true;\n    }\n    var maybeTransition;\n    function handleKeyBinding(e) {\n      // Handle auto keymap transitions\n      var startMap = getKeyMap(options.keyMap), next = startMap.auto;\n      clearTimeout(maybeTransition);\n      if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n        if (getKeyMap(options.keyMap) == startMap) {\n          options.keyMap = (next.call ? next.call(null, instance) : next);\n        }\n      }, 50);\n\n      var name = keyNames[e_prop(e, \"keyCode\")], handled = false;\n      if (name == null || e.altGraphKey) return false;\n      if (e_prop(e, \"altKey\")) name = \"Alt-\" + name;\n      if (e_prop(e, \"ctrlKey\")) name = \"Ctrl-\" + name;\n      if (e_prop(e, \"metaKey\")) name = \"Cmd-\" + name;\n\n      var stopped = false;\n      function stop() { stopped = true; }\n\n      if (e_prop(e, \"shiftKey\")) {\n        handled = lookupKey(\"Shift-\" + name, options.extraKeys, options.keyMap,\n                            function(b) {return doHandleBinding(b, true);}, stop)\n               || lookupKey(name, options.extraKeys, options.keyMap, function(b) {\n                 if (typeof b == \"string\" && /^go[A-Z]/.test(b)) return doHandleBinding(b);\n               }, stop);\n      } else {\n        handled = lookupKey(name, options.extraKeys, options.keyMap, doHandleBinding, stop);\n      }\n      if (stopped) handled = false;\n      if (handled) {\n        e_preventDefault(e);\n        restartBlink();\n        if (ie) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      }\n      return handled;\n    }\n    function handleCharBinding(e, ch) {\n      var handled = lookupKey(\"'\" + ch + \"'\", options.extraKeys,\n                              options.keyMap, function(b) { return doHandleBinding(b, true); });\n      if (handled) {\n        e_preventDefault(e);\n        restartBlink();\n      }\n      return handled;\n    }\n\n    var lastStoppedKey = null;\n    function onKeyDown(e) {\n      if (!focused) onFocus();\n      if (ie && e.keyCode == 27) { e.returnValue = false; }\n      if (pollingFast) { if (readInput()) pollingFast = false; }\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      var code = e_prop(e, \"keyCode\");\n      // IE does strange things with escape.\n      setShift(code == 16 || e_prop(e, \"shiftKey\"));\n      // First give onKeyEvent option a chance to handle this.\n      var handled = handleKeyBinding(e);\n      if (opera) {\n        lastStoppedKey = handled ? code : null;\n        // Opera has no cut event... we try to at least catch the key combo\n        if (!handled && code == 88 && e_prop(e, mac ? \"metaKey\" : \"ctrlKey\"))\n          replaceSelection(\"\");\n      }\n    }\n    function onKeyPress(e) {\n      if (pollingFast) readInput();\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      var keyCode = e_prop(e, \"keyCode\"), charCode = e_prop(e, \"charCode\");\n      if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n      if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(e)) return;\n      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n      if (options.electricChars && mode.electricChars && options.smartIndent && !options.readOnly) {\n        if (mode.electricChars.indexOf(ch) > -1)\n          setTimeout(operation(function() {indentLine(sel.to.line, \"smart\");}), 75);\n      }\n      if (handleCharBinding(e, ch)) return;\n      fastPoll();\n    }\n    function onKeyUp(e) {\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      if (e_prop(e, \"keyCode\") == 16) shiftSelecting = null;\n    }\n\n    function onFocus() {\n      if (options.readOnly == \"nocursor\") return;\n      if (!focused) {\n        if (options.onFocus) options.onFocus(instance);\n        focused = true;\n        if (scroller.className.search(/\\bCodeMirror-focused\\b/) == -1)\n          scroller.className += \" CodeMirror-focused\";\n      }\n      slowPoll();\n      restartBlink();\n    }\n    function onBlur() {\n      if (focused) {\n        if (options.onBlur) options.onBlur(instance);\n        focused = false;\n        if (bracketHighlighted)\n          operation(function(){\n            if (bracketHighlighted) { bracketHighlighted(); bracketHighlighted = null; }\n          })();\n        scroller.className = scroller.className.replace(\" CodeMirror-focused\", \"\");\n      }\n      clearInterval(blinker);\n      setTimeout(function() {if (!focused) shiftSelecting = null;}, 150);\n    }\n\n    // Replace the range from from to to by the strings in newText.\n    // Afterwards, set the selection to selFrom, selTo.\n    function updateLines(from, to, newText, selFrom, selTo) {\n      if (suppressEdits) return;\n      var old = [];\n      doc.iter(from.line, to.line + 1, function(line) {\n        old.push(newHL(line.text, line.markedSpans));\n      });\n      if (history) {\n        history.addChange(from.line, newText.length, old);\n        while (history.done.length > options.undoDepth) history.done.shift();\n      }\n      var lines = updateMarkedSpans(hlSpans(old[0]), hlSpans(lst(old)), from.ch, to.ch, newText);\n      updateLinesNoUndo(from, to, lines, selFrom, selTo);\n    }\n    function unredoHelper(from, to) {\n      if (!from.length) return;\n      var set = from.pop(), out = [];\n      for (var i = set.length - 1; i >= 0; i -= 1) {\n        var change = set[i];\n        var replaced = [], end = change.start + change.added;\n        doc.iter(change.start, end, function(line) { replaced.push(newHL(line.text, line.markedSpans)); });\n        out.push({start: change.start, added: change.old.length, old: replaced});\n        var pos = {line: change.start + change.old.length - 1,\n                   ch: editEnd(hlText(lst(replaced)), hlText(lst(change.old)))};\n        updateLinesNoUndo({line: change.start, ch: 0}, {line: end - 1, ch: getLine(end-1).text.length},\n                          change.old, pos, pos);\n      }\n      updateInput = true;\n      to.push(out);\n    }\n    function undo() {unredoHelper(history.done, history.undone);}\n    function redo() {unredoHelper(history.undone, history.done);}\n\n    function updateLinesNoUndo(from, to, lines, selFrom, selTo) {\n      if (suppressEdits) return;\n      var recomputeMaxLength = false, maxLineLength = maxLine.text.length;\n      if (!options.lineWrapping)\n        doc.iter(from.line, to.line + 1, function(line) {\n          if (!line.hidden && line.text.length == maxLineLength) {recomputeMaxLength = true; return true;}\n        });\n      if (from.line != to.line || lines.length > 1) gutterDirty = true;\n\n      var nlines = to.line - from.line, firstLine = getLine(from.line), lastLine = getLine(to.line);\n      var lastHL = lst(lines);\n\n      // First adjust the line structure\n      if (from.ch == 0 && to.ch == 0 && hlText(lastHL) == \"\") {\n        // This is a whole-line replace. Treated specially to make\n        // sure line objects move the way they are supposed to.\n        var added = [], prevLine = null;\n        for (var i = 0, e = lines.length - 1; i < e; ++i)\n          added.push(new Line(hlText(lines[i]), hlSpans(lines[i])));\n        lastLine.update(lastLine.text, hlSpans(lastHL));\n        if (nlines) doc.remove(from.line, nlines, callbacks);\n        if (added.length) doc.insert(from.line, added);\n      } else if (firstLine == lastLine) {\n        if (lines.length == 1) {\n          firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]) + firstLine.text.slice(to.ch), hlSpans(lines[0]));\n        } else {\n          for (var added = [], i = 1, e = lines.length - 1; i < e; ++i)\n            added.push(new Line(hlText(lines[i]), hlSpans(lines[i])));\n          added.push(new Line(hlText(lastHL) + firstLine.text.slice(to.ch), hlSpans(lastHL)));\n          firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]), hlSpans(lines[0]));\n          doc.insert(from.line + 1, added);\n        }\n      } else if (lines.length == 1) {\n        firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]) + lastLine.text.slice(to.ch), hlSpans(lines[0]));\n        doc.remove(from.line + 1, nlines, callbacks);\n      } else {\n        var added = [];\n        firstLine.update(firstLine.text.slice(0, from.ch) + hlText(lines[0]), hlSpans(lines[0]));\n        lastLine.update(hlText(lastHL) + lastLine.text.slice(to.ch), hlSpans(lastHL));\n        for (var i = 1, e = lines.length - 1; i < e; ++i)\n          added.push(new Line(hlText(lines[i]), hlSpans(lines[i])));\n        if (nlines > 1) doc.remove(from.line + 1, nlines - 1, callbacks);\n        doc.insert(from.line + 1, added);\n      }\n      if (options.lineWrapping) {\n        var perLine = Math.max(5, scroller.clientWidth / charWidth() - 3);\n        doc.iter(from.line, from.line + lines.length, function(line) {\n          if (line.hidden) return;\n          var guess = Math.ceil(line.text.length / perLine) || 1;\n          if (guess != line.height) updateLineHeight(line, guess);\n        });\n      } else {\n        doc.iter(from.line, from.line + lines.length, function(line) {\n          var l = line.text;\n          if (!line.hidden && l.length > maxLineLength) {\n            maxLine = line; maxLineLength = l.length; maxLineChanged = true;\n            recomputeMaxLength = false;\n          }\n        });\n        if (recomputeMaxLength) updateMaxLine = true;\n      }\n\n      // Adjust frontier, schedule worker\n      frontier = Math.min(frontier, from.line);\n      startWorker(400);\n\n      var lendiff = lines.length - nlines - 1;\n      // Remember that these lines changed, for updating the display\n      changes.push({from: from.line, to: to.line + 1, diff: lendiff});\n      if (options.onChange) {\n        // Normalize lines to contain only strings, since that's what\n        // the change event handler expects\n        for (var i = 0; i < lines.length; ++i)\n          if (typeof lines[i] != \"string\") lines[i] = lines[i].text;\n        var changeObj = {from: from, to: to, text: lines};\n        if (textChanged) {\n          for (var cur = textChanged; cur.next; cur = cur.next) {}\n          cur.next = changeObj;\n        } else textChanged = changeObj;\n      }\n\n      // Update the selection\n      function updateLine(n) {return n <= Math.min(to.line, to.line + lendiff) ? n : n + lendiff;}\n      setSelection(clipPos(selFrom), clipPos(selTo),\n                   updateLine(sel.from.line), updateLine(sel.to.line));\n    }\n\n    function needsScrollbar() {\n      var realHeight = doc.height * textHeight() + 2 * paddingTop();\n      return realHeight * .99 > scroller.offsetHeight ? realHeight : false;\n    }\n\n    function updateVerticalScroll(scrollTop) {\n      var scrollHeight = needsScrollbar();\n      scrollbar.style.display = scrollHeight ? \"block\" : \"none\";\n      if (scrollHeight) {\n        scrollbarInner.style.height = sizer.style.minHeight = scrollHeight + \"px\";\n        scrollbar.style.height = scroller.clientHeight + \"px\";\n        if (scrollTop != null) {\n          scrollbar.scrollTop = scroller.scrollTop = scrollTop;\n          // 'Nudge' the scrollbar to work around a Webkit bug where,\n          // in some situations, we'd end up with a scrollbar that\n          // reported its scrollTop (and looked) as expected, but\n          // *behaved* as if it was still in a previous state (i.e.\n          // couldn't scroll up, even though it appeared to be at the\n          // bottom).\n          if (webkit) setTimeout(function() {\n            if (scrollbar.scrollTop != scrollTop) return;\n            scrollbar.scrollTop = scrollTop + (scrollTop ? -1 : 1);\n            scrollbar.scrollTop = scrollTop;\n          }, 0);\n        }\n      } else {\n        sizer.style.minHeight = \"\";\n      }\n      // Position the mover div to align with the current virtual scroll position\n      mover.style.top = displayOffset * textHeight() + \"px\";\n    }\n\n    function computeMaxLength() {\n      maxLine = getLine(0); maxLineChanged = true;\n      var maxLineLength = maxLine.text.length;\n      doc.iter(1, doc.size, function(line) {\n        var l = line.text;\n        if (!line.hidden && l.length > maxLineLength) {\n          maxLineLength = l.length; maxLine = line;\n        }\n      });\n      updateMaxLine = false;\n    }\n\n    function replaceRange(code, from, to) {\n      from = clipPos(from);\n      if (!to) to = from; else to = clipPos(to);\n      code = splitLines(code);\n      function adjustPos(pos) {\n        if (posLess(pos, from)) return pos;\n        if (!posLess(to, pos)) return end;\n        var line = pos.line + code.length - (to.line - from.line) - 1;\n        var ch = pos.ch;\n        if (pos.line == to.line)\n          ch += lst(code).length - (to.ch - (to.line == from.line ? from.ch : 0));\n        return {line: line, ch: ch};\n      }\n      var end;\n      replaceRange1(code, from, to, function(end1) {\n        end = end1;\n        return {from: adjustPos(sel.from), to: adjustPos(sel.to)};\n      });\n      return end;\n    }\n    function replaceSelection(code, collapse) {\n      replaceRange1(splitLines(code), sel.from, sel.to, function(end) {\n        if (collapse == \"end\") return {from: end, to: end};\n        else if (collapse == \"start\") return {from: sel.from, to: sel.from};\n        else return {from: sel.from, to: end};\n      });\n    }\n    function replaceRange1(code, from, to, computeSel) {\n      var endch = code.length == 1 ? code[0].length + from.ch : lst(code).length;\n      var newSel = computeSel({line: from.line + code.length - 1, ch: endch});\n      updateLines(from, to, code, newSel.from, newSel.to);\n    }\n\n    function getRange(from, to, lineSep) {\n      var l1 = from.line, l2 = to.line;\n      if (l1 == l2) return getLine(l1).text.slice(from.ch, to.ch);\n      var code = [getLine(l1).text.slice(from.ch)];\n      doc.iter(l1 + 1, l2, function(line) { code.push(line.text); });\n      code.push(getLine(l2).text.slice(0, to.ch));\n      return code.join(lineSep || \"\\n\");\n    }\n    function getSelection(lineSep) {\n      return getRange(sel.from, sel.to, lineSep);\n    }\n\n    function slowPoll() {\n      if (pollingFast) return;\n      poll.set(options.pollInterval, function() {\n        readInput();\n        if (focused) slowPoll();\n      });\n    }\n    function fastPoll() {\n      var missed = false;\n      pollingFast = true;\n      function p() {\n        var changed = readInput();\n        if (!changed && !missed) {missed = true; poll.set(60, p);}\n        else {pollingFast = false; slowPoll();}\n      }\n      poll.set(20, p);\n    }\n\n    // Previnput is a hack to work with IME. If we reset the textarea\n    // on every change, that breaks IME. So we look for changes\n    // compared to the previous content instead. (Modern browsers have\n    // events that indicate IME taking place, but these are not widely\n    // supported or compatible enough yet to rely on.)\n    var prevInput = \"\";\n    function readInput() {\n      if (!focused || hasSelection(input) || options.readOnly) return false;\n      var text = input.value;\n      if (text == prevInput) return false;\n      if (!nestedOperation) startOperation();\n      shiftSelecting = null;\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput[same] == text[same]) ++same;\n      if (same < prevInput.length)\n        sel.from = {line: sel.from.line, ch: sel.from.ch - (prevInput.length - same)};\n      else if (overwrite && posEq(sel.from, sel.to))\n        sel.to = {line: sel.to.line, ch: Math.min(getLine(sel.to.line).text.length, sel.to.ch + (text.length - same))};\n      replaceSelection(text.slice(same), \"end\");\n      if (text.length > 1000) { input.value = prevInput = \"\"; }\n      else prevInput = text;\n      if (!nestedOperation) endOperation();\n      return true;\n    }\n    function resetInput(user) {\n      if (!posEq(sel.from, sel.to)) {\n        prevInput = \"\";\n        input.value = getSelection();\n        if (focused) selectInput(input);\n      } else if (user) prevInput = input.value = \"\";\n    }\n\n    function focusInput() {\n      if (options.readOnly != \"nocursor\") input.focus();\n    }\n\n    function scrollCursorIntoView() {\n      var coords = calculateCursorCoords();\n      scrollIntoView(coords.x, coords.y, coords.x, coords.yBot);\n      if (!focused) return;\n      var box = sizer.getBoundingClientRect(), doScroll = null;\n      if (coords.y + box.top < 0) doScroll = true;\n      else if (coords.y + box.top + textHeight() > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n      if (doScroll != null) {\n        var hidden = cursor.style.display == \"none\";\n        if (hidden) {\n          cursor.style.display = \"\";\n          cursor.style.left = coords.x + \"px\";\n          cursor.style.top = (coords.y - displayOffset) + \"px\";\n        }\n        cursor.scrollIntoView(doScroll);\n        if (hidden) cursor.style.display = \"none\";\n      }\n    }\n    function calculateCursorCoords() {\n      var cursor = localCoords(sel.inverted ? sel.from : sel.to);\n      var x = options.lineWrapping ? Math.min(cursor.x, lineSpace.offsetWidth) : cursor.x;\n      return {x: x, y: cursor.y, yBot: cursor.yBot};\n    }\n    function scrollIntoView(x1, y1, x2, y2) {\n      var scrollPos = calculateScrollPos(x1, y1, x2, y2);\n      if (scrollPos.scrollLeft != null) {scroller.scrollLeft = scrollPos.scrollLeft;}\n      if (scrollPos.scrollTop != null) {scrollbar.scrollTop = scroller.scrollTop = scrollPos.scrollTop;}\n    }\n    function calculateScrollPos(x1, y1, x2, y2) {\n      var pl = paddingLeft(), pt = paddingTop();\n      y1 += pt; y2 += pt; x1 += pl; x2 += pl;\n      var screen = scroller.clientHeight, screentop = scrollbar.scrollTop, result = {};\n      var docBottom = needsScrollbar() || Infinity;\n      var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;\n      if (y1 < screentop) result.scrollTop = atTop ? 0 : Math.max(0, y1);\n      else if (y2 > screentop + screen) result.scrollTop = (atBottom ? docBottom : y2) - screen;\n\n      var screenw = scroller.clientWidth, screenleft = scroller.scrollLeft;\n      var gutterw = options.fixedGutter ? gutter.clientWidth : 0;\n      var atLeft = x1 < gutterw + pl + 10;\n      if (x1 < screenleft + gutterw || atLeft) {\n        if (atLeft) x1 = 0;\n        result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n      } else if (x2 > screenw + screenleft - 3) {\n        result.scrollLeft = x2 + 10 - screenw;\n      }\n      return result;\n    }\n\n    function visibleLines(scrollTop) {\n      var lh = textHeight(), top = (scrollTop != null ? scrollTop : scrollbar.scrollTop) - paddingTop();\n      var fromHeight = Math.max(0, Math.floor(top / lh));\n      var toHeight = Math.ceil((top + scroller.clientHeight) / lh);\n      return {from: lineAtHeight(doc, fromHeight),\n              to: lineAtHeight(doc, toHeight)};\n    }\n    // Uses a set of changes plus the current scroll position to\n    // determine which DOM updates have to be made, and makes the\n    // updates.\n    function updateDisplay(changes, suppressCallback, scrollTop) {\n      if (!scroller.clientWidth) {\n        showingFrom = showingTo = displayOffset = 0;\n        return;\n      }\n      // Compute the new visible window\n      // If scrollTop is specified, use that to determine which lines\n      // to render instead of the current scrollbar position.\n      var visible = visibleLines(scrollTop);\n      // Bail out if the visible area is already rendered and nothing changed.\n      if (changes !== true && changes.length == 0 && visible.from > showingFrom && visible.to < showingTo) {\n        updateVerticalScroll(scrollTop);\n        return;\n      }\n      var from = Math.max(visible.from - 100, 0), to = Math.min(doc.size, visible.to + 100);\n      if (showingFrom < from && from - showingFrom < 20) from = showingFrom;\n      if (showingTo > to && showingTo - to < 20) to = Math.min(doc.size, showingTo);\n\n      // Create a range of theoretically intact lines, and punch holes\n      // in that using the change info.\n      var intact = changes === true ? [] :\n        computeIntact([{from: showingFrom, to: showingTo, domStart: 0}], changes);\n      // Clip off the parts that won't be visible\n      var intactLines = 0;\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i];\n        if (range.from < from) {range.domStart += (from - range.from); range.from = from;}\n        if (range.to > to) range.to = to;\n        if (range.from >= range.to) intact.splice(i--, 1);\n        else intactLines += range.to - range.from;\n      }\n      if (intactLines == to - from && from == showingFrom && to == showingTo) {\n        updateVerticalScroll(scrollTop);\n        return;\n      }\n      intact.sort(function(a, b) {return a.domStart - b.domStart;});\n\n      var th = textHeight(), gutterDisplay = gutter.style.display;\n      lineDiv.style.display = \"none\";\n      patchDisplay(from, to, intact);\n      lineDiv.style.display = gutter.style.display = \"\";\n\n      var different = from != showingFrom || to != showingTo || lastSizeC != scroller.clientHeight + th;\n      // This is just a bogus formula that detects when the editor is\n      // resized or the font size changes.\n      if (different) lastSizeC = scroller.clientHeight + th;\n      if (from != showingFrom || to != showingTo && options.onViewportChange)\n        setTimeout(function(){\n          if (options.onViewportChange) options.onViewportChange(instance, from, to);\n        });\n      showingFrom = from; showingTo = to;\n      displayOffset = heightAtLine(doc, from);\n      startWorker(100);\n\n      // Since this is all rather error prone, it is honoured with the\n      // only assertion in the whole file.\n      if (lineDiv.childNodes.length != showingTo - showingFrom)\n        throw new Error(\"BAD PATCH! \" + JSON.stringify(intact) + \" size=\" + (showingTo - showingFrom) +\n                        \" nodes=\" + lineDiv.childNodes.length);\n\n      function checkHeights() {\n        var curNode = lineDiv.firstChild, heightChanged = false;\n        doc.iter(showingFrom, showingTo, function(line) {\n          // Work around bizarro IE7 bug where, sometimes, our curNode\n          // is magically replaced with a new node in the DOM, leaving\n          // us with a reference to an orphan (nextSibling-less) node.\n          if (!curNode) return;\n          if (!line.hidden) {\n            var height = Math.round(curNode.offsetHeight / th) || 1;\n            if (line.height != height) {\n              updateLineHeight(line, height);\n              gutterDirty = heightChanged = true;\n            }\n          }\n          curNode = curNode.nextSibling;\n        });\n        return heightChanged;\n      }\n\n      if (options.lineWrapping) checkHeights();\n\n      gutter.style.display = gutterDisplay;\n      if (different || gutterDirty) {\n        // If the gutter grew in size, re-check heights. If those changed, re-draw gutter.\n        updateGutter() && options.lineWrapping && checkHeights() && updateGutter();\n      }\n      updateVerticalScroll(scrollTop);\n      updateSelection();\n      if (!suppressCallback && options.onUpdate) options.onUpdate(instance);\n      return true;\n    }\n\n    function computeIntact(intact, changes) {\n      for (var i = 0, l = changes.length || 0; i < l; ++i) {\n        var change = changes[i], intact2 = [], diff = change.diff || 0;\n        for (var j = 0, l2 = intact.length; j < l2; ++j) {\n          var range = intact[j];\n          if (change.to <= range.from && change.diff)\n            intact2.push({from: range.from + diff, to: range.to + diff,\n                          domStart: range.domStart});\n          else if (change.to <= range.from || change.from >= range.to)\n            intact2.push(range);\n          else {\n            if (change.from > range.from)\n              intact2.push({from: range.from, to: change.from, domStart: range.domStart});\n            if (change.to < range.to)\n              intact2.push({from: change.to + diff, to: range.to + diff,\n                            domStart: range.domStart + (change.to - range.from)});\n          }\n        }\n        intact = intact2;\n      }\n      return intact;\n    }\n\n    function patchDisplay(from, to, intact) {\n      function killNode(node) {\n        var tmp = node.nextSibling;\n        node.parentNode.removeChild(node);\n        return tmp;\n      }\n      // The first pass removes the DOM nodes that aren't intact.\n      if (!intact.length) removeChildren(lineDiv);\n      else {\n        var domPos = 0, curNode = lineDiv.firstChild, n;\n        for (var i = 0; i < intact.length; ++i) {\n          var cur = intact[i];\n          while (cur.domStart > domPos) {curNode = killNode(curNode); domPos++;}\n          for (var j = 0, e = cur.to - cur.from; j < e; ++j) {curNode = curNode.nextSibling; domPos++;}\n        }\n        while (curNode) curNode = killNode(curNode);\n      }\n      // This pass fills in the lines that actually changed.\n      var nextIntact = intact.shift(), curNode = lineDiv.firstChild, j = from;\n      doc.iter(from, to, function(line) {\n        if (nextIntact && nextIntact.to == j) nextIntact = intact.shift();\n        if (!nextIntact || nextIntact.from > j) {\n          if (line.hidden) var lineElement = elt(\"pre\");\n          else {\n            var lineElement = lineContent(line);\n            if (line.className) lineElement.className = line.className;\n            // Kludge to make sure the styled element lies behind the selection (by z-index)\n            if (line.bgClassName) {\n              var pre = elt(\"pre\", \"\\u00a0\", line.bgClassName, \"position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: -2\");\n              lineElement = elt(\"div\", [pre, lineElement], null, \"position: relative\");\n            }\n          }\n          lineDiv.insertBefore(lineElement, curNode);\n        } else {\n          curNode = curNode.nextSibling;\n        }\n        ++j;\n      });\n    }\n\n    function updateGutter() {\n      if (!options.gutter && !options.lineNumbers) return;\n      var hText = mover.offsetHeight, hEditor = scroller.clientHeight;\n      gutter.style.height = (hText - hEditor < 2 ? hEditor : hText) + \"px\";\n      var fragment = document.createDocumentFragment(), i = showingFrom, normalNode;\n      doc.iter(showingFrom, Math.max(showingTo, showingFrom + 1), function(line) {\n        if (line.hidden) {\n          fragment.appendChild(elt(\"pre\"));\n        } else {\n          var marker = line.gutterMarker;\n          var text = options.lineNumbers ? options.lineNumberFormatter(i + options.firstLineNumber) : null;\n          if (marker && marker.text)\n            text = marker.text.replace(\"%N%\", text != null ? text : \"\");\n          else if (text == null)\n            text = \"\\u00a0\";\n          var markerElement = fragment.appendChild(elt(\"pre\", null, marker && marker.style));\n          markerElement.innerHTML = text;\n          for (var j = 1; j < line.height; ++j) {\n            markerElement.appendChild(elt(\"br\"));\n            markerElement.appendChild(document.createTextNode(\"\\u00a0\"));\n          }\n          if (!marker) normalNode = i;\n        }\n        ++i;\n      });\n      gutter.style.display = \"none\";\n      removeChildrenAndAdd(gutterText, fragment);\n      // Make sure scrolling doesn't cause number gutter size to pop\n      if (normalNode != null && options.lineNumbers) {\n        var node = gutterText.childNodes[normalNode - showingFrom];\n        var minwidth = String(doc.size).length, val = eltText(node.firstChild), pad = \"\";\n        while (val.length + pad.length < minwidth) pad += \"\\u00a0\";\n        if (pad) node.insertBefore(document.createTextNode(pad), node.firstChild);\n      }\n      gutter.style.display = \"\";\n      var resized = Math.abs((parseInt(lineSpace.style.marginLeft) || 0) - gutter.offsetWidth) > 2;\n      lineSpace.style.marginLeft = gutter.offsetWidth + \"px\";\n      gutterDirty = false;\n      return resized;\n    }\n    function updateSelection() {\n      var collapsed = posEq(sel.from, sel.to);\n      var fromPos = localCoords(sel.from, true);\n      var toPos = collapsed ? fromPos : localCoords(sel.to, true);\n      var headPos = sel.inverted ? fromPos : toPos, th = textHeight();\n      var wrapOff = eltOffset(wrapper), lineOff = eltOffset(lineDiv);\n      inputDiv.style.top = Math.max(0, Math.min(scroller.offsetHeight, headPos.y + lineOff.top - wrapOff.top)) + \"px\";\n      inputDiv.style.left = Math.max(0, Math.min(scroller.offsetWidth, headPos.x + lineOff.left - wrapOff.left)) + \"px\";\n      if (collapsed) {\n        cursor.style.top = headPos.y + \"px\";\n        cursor.style.left = (options.lineWrapping ? Math.min(headPos.x, lineSpace.offsetWidth) : headPos.x) + \"px\";\n        cursor.style.display = \"\";\n        selectionDiv.style.display = \"none\";\n      } else {\n        var sameLine = fromPos.y == toPos.y, fragment = document.createDocumentFragment();\n        var clientWidth = lineSpace.clientWidth || lineSpace.offsetWidth;\n        var clientHeight = lineSpace.clientHeight || lineSpace.offsetHeight;\n        var add = function(left, top, right, height) {\n          var rstyle = quirksMode ? \"width: \" + (!right ? clientWidth : clientWidth - right - left) + \"px\"\n                                  : \"right: \" + right + \"px\";\n          fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                                   \"px; top: \" + top + \"px; \" + rstyle + \"; height: \" + height + \"px\"));\n        };\n        if (sel.from.ch && fromPos.y >= 0) {\n          var right = sameLine ? clientWidth - toPos.x : 0;\n          add(fromPos.x, fromPos.y, right, th);\n        }\n        var middleStart = Math.max(0, fromPos.y + (sel.from.ch ? th : 0));\n        var middleHeight = Math.min(toPos.y, clientHeight) - middleStart;\n        if (middleHeight > 0.2 * th)\n          add(0, middleStart, 0, middleHeight);\n        if ((!sameLine || !sel.from.ch) && toPos.y < clientHeight - .5 * th)\n          add(0, toPos.y, clientWidth - toPos.x, th);\n        removeChildrenAndAdd(selectionDiv, fragment);\n        cursor.style.display = \"none\";\n        selectionDiv.style.display = \"\";\n      }\n    }\n\n    function setShift(val) {\n      if (val) shiftSelecting = shiftSelecting || (sel.inverted ? sel.to : sel.from);\n      else shiftSelecting = null;\n    }\n    function setSelectionUser(from, to) {\n      var sh = shiftSelecting && clipPos(shiftSelecting);\n      if (sh) {\n        if (posLess(sh, from)) from = sh;\n        else if (posLess(to, sh)) to = sh;\n      }\n      setSelection(from, to);\n      userSelChange = true;\n    }\n    // Update the selection. Last two args are only used by\n    // updateLines, since they have to be expressed in the line\n    // numbers before the update.\n    function setSelection(from, to, oldFrom, oldTo) {\n      goalColumn = null;\n      if (oldFrom == null) {oldFrom = sel.from.line; oldTo = sel.to.line;}\n      if (posEq(sel.from, from) && posEq(sel.to, to)) return;\n      if (posLess(to, from)) {var tmp = to; to = from; from = tmp;}\n\n      // Skip over hidden lines.\n      if (from.line != oldFrom) {\n        var from1 = skipHidden(from, oldFrom, sel.from.ch);\n        // If there is no non-hidden line left, force visibility on current line\n        if (!from1) setLineHidden(from.line, false);\n        else from = from1;\n      }\n      if (to.line != oldTo) to = skipHidden(to, oldTo, sel.to.ch);\n\n      if (posEq(from, to)) sel.inverted = false;\n      else if (posEq(from, sel.to)) sel.inverted = false;\n      else if (posEq(to, sel.from)) sel.inverted = true;\n\n      if (options.autoClearEmptyLines && posEq(sel.from, sel.to)) {\n        var head = sel.inverted ? from : to;\n        if (head.line != sel.from.line && sel.from.line < doc.size) {\n          var oldLine = getLine(sel.from.line);\n          if (/^\\s+$/.test(oldLine.text))\n            setTimeout(operation(function() {\n              if (oldLine.parent && /^\\s+$/.test(oldLine.text)) {\n                var no = lineNo(oldLine);\n                replaceRange(\"\", {line: no, ch: 0}, {line: no, ch: oldLine.text.length});\n              }\n            }, 10));\n        }\n      }\n\n      sel.from = from; sel.to = to;\n      selectionChanged = true;\n    }\n    function skipHidden(pos, oldLine, oldCh) {\n      function getNonHidden(dir) {\n        var lNo = pos.line + dir, end = dir == 1 ? doc.size : -1;\n        while (lNo != end) {\n          var line = getLine(lNo);\n          if (!line.hidden) {\n            var ch = pos.ch;\n            if (toEnd || ch > oldCh || ch > line.text.length) ch = line.text.length;\n            return {line: lNo, ch: ch};\n          }\n          lNo += dir;\n        }\n      }\n      var line = getLine(pos.line);\n      var toEnd = pos.ch == line.text.length && pos.ch != oldCh;\n      if (!line.hidden) return pos;\n      if (pos.line >= oldLine) return getNonHidden(1) || getNonHidden(-1);\n      else return getNonHidden(-1) || getNonHidden(1);\n    }\n    function setCursor(line, ch, user) {\n      var pos = clipPos({line: line, ch: ch || 0});\n      (user ? setSelectionUser : setSelection)(pos, pos);\n    }\n\n    function clipLine(n) {return Math.max(0, Math.min(n, doc.size-1));}\n    function clipPos(pos) {\n      if (pos.line < 0) return {line: 0, ch: 0};\n      if (pos.line >= doc.size) return {line: doc.size-1, ch: getLine(doc.size-1).text.length};\n      var ch = pos.ch, linelen = getLine(pos.line).text.length;\n      if (ch == null || ch > linelen) return {line: pos.line, ch: linelen};\n      else if (ch < 0) return {line: pos.line, ch: 0};\n      else return pos;\n    }\n\n    function findPosH(dir, unit) {\n      var end = sel.inverted ? sel.from : sel.to, line = end.line, ch = end.ch;\n      var lineObj = getLine(line);\n      function findNextLine() {\n        for (var l = line + dir, e = dir < 0 ? -1 : doc.size; l != e; l += dir) {\n          var lo = getLine(l);\n          if (!lo.hidden) { line = l; lineObj = lo; return true; }\n        }\n      }\n      function moveOnce(boundToLine) {\n        if (ch == (dir < 0 ? 0 : lineObj.text.length)) {\n          if (!boundToLine && findNextLine()) ch = dir < 0 ? lineObj.text.length : 0;\n          else return false;\n        } else ch += dir;\n        return true;\n      }\n      if (unit == \"char\") moveOnce();\n      else if (unit == \"column\") moveOnce(true);\n      else if (unit == \"word\") {\n        var sawWord = false;\n        for (;;) {\n          if (dir < 0) if (!moveOnce()) break;\n          if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;\n          else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}\n          if (dir > 0) if (!moveOnce()) break;\n        }\n      }\n      return {line: line, ch: ch};\n    }\n    function moveH(dir, unit) {\n      var pos = dir < 0 ? sel.from : sel.to;\n      if (shiftSelecting || posEq(sel.from, sel.to)) pos = findPosH(dir, unit);\n      setCursor(pos.line, pos.ch, true);\n    }\n    function deleteH(dir, unit) {\n      if (!posEq(sel.from, sel.to)) replaceRange(\"\", sel.from, sel.to);\n      else if (dir < 0) replaceRange(\"\", findPosH(dir, unit), sel.to);\n      else replaceRange(\"\", sel.from, findPosH(dir, unit));\n      userSelChange = true;\n    }\n    function moveV(dir, unit) {\n      var dist = 0, pos = localCoords(sel.inverted ? sel.from : sel.to, true);\n      if (goalColumn != null) pos.x = goalColumn;\n      if (unit == \"page\") {\n        var screen = Math.min(scroller.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n        var target = coordsChar(pos.x, pos.y + screen * dir);\n      } else if (unit == \"line\") {\n        var th = textHeight();\n        var target = coordsChar(pos.x, pos.y + .5 * th + dir * th);\n      }\n      if (unit == \"page\") scrollbar.scrollTop += localCoords(target, true).y - pos.y;\n      setCursor(target.line, target.ch, true);\n      goalColumn = pos.x;\n    }\n\n    function findWordAt(pos) {\n      var line = getLine(pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        if (pos.after === false || end == line.length) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar) ? isWordChar :\n                    /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);} :\n                    function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return {from: {line: pos.line, ch: start}, to: {line: pos.line, ch: end}};\n    }\n    function selectLine(line) {\n      setSelectionUser({line: line, ch: 0}, clipPos({line: line + 1, ch: 0}));\n    }\n    function indentSelected(mode) {\n      if (posEq(sel.from, sel.to)) return indentLine(sel.from.line, mode);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(i, mode);\n    }\n\n    function indentLine(n, how) {\n      if (!how) how = \"add\";\n      if (how == \"smart\") {\n        if (!mode.indent) how = \"prev\";\n        else var state = getStateBefore(n);\n      }\n\n      var line = getLine(n), curSpace = line.indentation(options.tabSize),\n          curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n      if (how == \"smart\") {\n        indentation = mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n        if (indentation == Pass) how = \"prev\";\n      }\n      if (how == \"prev\") {\n        if (n) indentation = getLine(n-1).indentation(options.tabSize);\n        else indentation = 0;\n      }\n      else if (how == \"add\") indentation = curSpace + options.indentUnit;\n      else if (how == \"subtract\") indentation = curSpace - options.indentUnit;\n      indentation = Math.max(0, indentation);\n      var diff = indentation - curSpace;\n\n      var indentString = \"\", pos = 0;\n      if (options.indentWithTabs)\n        for (var i = Math.floor(indentation / options.tabSize); i; --i) {pos += options.tabSize; indentString += \"\\t\";}\n      if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n      if (indentString != curSpaceString)\n        replaceRange(indentString, {line: n, ch: 0}, {line: n, ch: curSpaceString.length});\n    }\n\n    function loadMode() {\n      mode = CodeMirror.getMode(options, options.mode);\n      doc.iter(0, doc.size, function(line) { line.stateAfter = null; });\n      frontier = 0;\n      startWorker(100);\n    }\n    function gutterChanged() {\n      var visible = options.gutter || options.lineNumbers;\n      gutter.style.display = visible ? \"\" : \"none\";\n      if (visible) gutterDirty = true;\n      else lineDiv.parentNode.style.marginLeft = 0;\n    }\n    function wrappingChanged(from, to) {\n      if (options.lineWrapping) {\n        wrapper.className += \" CodeMirror-wrap\";\n        var perLine = scroller.clientWidth / charWidth() - 3;\n        doc.iter(0, doc.size, function(line) {\n          if (line.hidden) return;\n          var guess = Math.ceil(line.text.length / perLine) || 1;\n          if (guess != 1) updateLineHeight(line, guess);\n        });\n        lineSpace.style.minWidth = widthForcer.style.left = \"\";\n      } else {\n        wrapper.className = wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n        computeMaxLength();\n        doc.iter(0, doc.size, function(line) {\n          if (line.height != 1 && !line.hidden) updateLineHeight(line, 1);\n        });\n      }\n      changes.push({from: 0, to: doc.size});\n    }\n    function themeChanged() {\n      scroller.className = scroller.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n        options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    }\n    function keyMapChanged() {\n      var style = keyMap[options.keyMap].style;\n      wrapper.className = wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n        (style ? \" cm-keymap-\" + style : \"\");\n    }\n\n    function TextMarker(type, style) { this.lines = []; this.type = type; if (style) this.style = style; }\n    TextMarker.prototype.clear = operation(function() {\n      var min = Infinity, max = -Infinity;\n      for (var i = 0; i < this.lines.length; ++i) {\n        var line = this.lines[i];\n        var span = getMarkedSpanFor(line.markedSpans, this, true);\n        if (span.from != null || span.to != null) {\n          var lineN = lineNo(line);\n          min = Math.min(min, lineN); max = Math.max(max, lineN);\n        }\n      }\n      if (min != Infinity)\n        changes.push({from: min, to: max + 1});\n      this.lines.length = 0;\n    });\n    TextMarker.prototype.find = function() {\n      var from, to;\n      for (var i = 0; i < this.lines.length; ++i) {\n        var line = this.lines[i];\n        var span = getMarkedSpanFor(line.markedSpans, this);\n        if (span.from != null || span.to != null) {\n          var found = lineNo(line);\n          if (span.from != null) from = {line: found, ch: span.from};\n          if (span.to != null) to = {line: found, ch: span.to};\n        }\n      }\n      if (this.type == \"bookmark\") return from;\n      return from && {from: from, to: to};\n    };\n\n    function markText(from, to, className, options) {\n      from = clipPos(from); to = clipPos(to);\n      var marker = new TextMarker(\"range\", className);\n      if (options && options.inclusiveLeft) marker.inclusiveLeft = true;\n      if (options && options.inclusiveRight) marker.inclusiveRight = true;\n      var curLine = from.line;\n      doc.iter(curLine, to.line + 1, function(line) {\n        var span = {from: curLine == from.line ? from.ch : null,\n                    to: curLine == to.line ? to.ch : null,\n                    marker: marker};\n        (line.markedSpans || (line.markedSpans = [])).push(span);\n        marker.lines.push(line);\n        ++curLine;\n      });\n      changes.push({from: from.line, to: to.line + 1});\n      return marker;\n    }\n\n    function setBookmark(pos) {\n      pos = clipPos(pos);\n      var marker = new TextMarker(\"bookmark\"), line = getLine(pos.line);\n      var span = {from: pos.ch, to: pos.ch, marker: marker};\n      (line.markedSpans || (line.markedSpans = [])).push(span);\n      marker.lines.push(line);\n      return marker;\n    }\n\n    function findMarksAt(pos) {\n      pos = clipPos(pos);\n      var markers = [], spans = getLine(pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker);\n      }\n      return markers;\n    }\n\n    function addGutterMarker(line, text, className) {\n      if (typeof line == \"number\") line = getLine(clipLine(line));\n      line.gutterMarker = {text: text, style: className};\n      gutterDirty = true;\n      return line;\n    }\n    function removeGutterMarker(line) {\n      if (typeof line == \"number\") line = getLine(clipLine(line));\n      line.gutterMarker = null;\n      gutterDirty = true;\n    }\n\n    function changeLine(handle, op) {\n      var no = handle, line = handle;\n      if (typeof handle == \"number\") line = getLine(clipLine(handle));\n      else no = lineNo(handle);\n      if (no == null) return null;\n      if (op(line, no)) changes.push({from: no, to: no + 1});\n      else return null;\n      return line;\n    }\n    function setLineClass(handle, className, bgClassName) {\n      return changeLine(handle, function(line) {\n        if (line.className != className || line.bgClassName != bgClassName) {\n          line.className = className;\n          line.bgClassName = bgClassName;\n          return true;\n        }\n      });\n    }\n    function setLineHidden(handle, hidden) {\n      return changeLine(handle, function(line, no) {\n        if (line.hidden != hidden) {\n          line.hidden = hidden;\n          if (!options.lineWrapping) {\n            if (hidden && line.text.length == maxLine.text.length) {\n              updateMaxLine = true;\n            } else if (!hidden && line.text.length > maxLine.text.length) {\n              maxLine = line; updateMaxLine = false;\n            }\n          }\n          updateLineHeight(line, hidden ? 0 : 1);\n          var fline = sel.from.line, tline = sel.to.line;\n          if (hidden && (fline == no || tline == no)) {\n            var from = fline == no ? skipHidden({line: fline, ch: 0}, fline, 0) : sel.from;\n            var to = tline == no ? skipHidden({line: tline, ch: 0}, tline, 0) : sel.to;\n            // Can't hide the last visible line, we'd have no place to put the cursor\n            if (!to) return;\n            setSelection(from, to);\n          }\n          return (gutterDirty = true);\n        }\n      });\n    }\n\n    function lineInfo(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(line)) return null;\n        var n = line;\n        line = getLine(line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      var marker = line.gutterMarker;\n      return {line: n, handle: line, text: line.text, markerText: marker && marker.text,\n              markerClass: marker && marker.style, lineClass: line.className, bgClass: line.bgClassName};\n    }\n\n    function measureLine(line, ch) {\n      if (ch == 0) return {top: 0, left: 0};\n      var wbr = options.lineWrapping && ch < line.text.length &&\n                spanAffectsWrapping.test(line.text.slice(ch - 1, ch + 1));\n      var pre = lineContent(line, ch);\n      removeChildrenAndAdd(measure, pre);\n      var anchor = pre.anchor;\n      var top = anchor.offsetTop, left = anchor.offsetLeft;\n      // Older IEs report zero offsets for spans directly after a wrap\n      if (ie && top == 0 && left == 0) {\n        var backup = elt(\"span\", \"x\");\n        anchor.parentNode.insertBefore(backup, anchor.nextSibling);\n        top = backup.offsetTop;\n      }\n      return {top: top, left: left};\n    }\n    function localCoords(pos, inLineWrap) {\n      var x, lh = textHeight(), y = lh * (heightAtLine(doc, pos.line) - (inLineWrap ? displayOffset : 0));\n      if (pos.ch == 0) x = 0;\n      else {\n        var sp = measureLine(getLine(pos.line), pos.ch);\n        x = sp.left;\n        if (options.lineWrapping) y += Math.max(0, sp.top);\n      }\n      return {x: x, y: y, yBot: y + lh};\n    }\n    // Coords must be lineSpace-local\n    function coordsChar(x, y) {\n      var th = textHeight(), cw = charWidth(), heightPos = displayOffset + Math.floor(y / th);\n      if (heightPos < 0) return {line: 0, ch: 0};\n      var lineNo = lineAtHeight(doc, heightPos);\n      if (lineNo >= doc.size) return {line: doc.size - 1, ch: getLine(doc.size - 1).text.length};\n      var lineObj = getLine(lineNo), text = lineObj.text;\n      var tw = options.lineWrapping, innerOff = tw ? heightPos - heightAtLine(doc, lineNo) : 0;\n      if (x <= 0 && innerOff == 0) return {line: lineNo, ch: 0};\n      var wrongLine = false;\n      function getX(len) {\n        var sp = measureLine(lineObj, len);\n        if (tw) {\n          var off = Math.round(sp.top / th);\n          wrongLine = off != innerOff;\n          return Math.max(0, sp.left + (off - innerOff) * scroller.clientWidth);\n        }\n        return sp.left;\n      }\n      var from = 0, fromX = 0, to = text.length, toX;\n      // Guess a suitable upper bound for our search.\n      var estimated = Math.min(to, Math.ceil((x + innerOff * scroller.clientWidth * .9) / cw));\n      for (;;) {\n        var estX = getX(estimated);\n        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));\n        else {toX = estX; to = estimated; break;}\n      }\n      if (x > toX) return {line: lineNo, ch: to};\n      // Try to guess a suitable lower bound as well.\n      estimated = Math.floor(to * 0.8); estX = getX(estimated);\n      if (estX < x) {from = estimated; fromX = estX;}\n      // Do a binary search between these bounds.\n      for (;;) {\n        if (to - from <= 1) {\n          var after = x - fromX < toX - x;\n          return {line: lineNo, ch: after ? from : to, after: after};\n        }\n        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);\n        if (middleX > x) {to = middle; toX = middleX; if (wrongLine) toX += 1000; }\n        else {from = middle; fromX = middleX;}\n      }\n    }\n    function pageCoords(pos) {\n      var local = localCoords(pos, true), off = eltOffset(lineSpace);\n      return {x: off.left + local.x, y: off.top + local.y, yBot: off.top + local.yBot};\n    }\n\n    var cachedHeight, cachedHeightFor, measurePre;\n    function textHeight() {\n      if (measurePre == null) {\n        measurePre = elt(\"pre\");\n        for (var i = 0; i < 49; ++i) {\n          measurePre.appendChild(document.createTextNode(\"x\"));\n          measurePre.appendChild(elt(\"br\"));\n        }\n        measurePre.appendChild(document.createTextNode(\"x\"));\n      }\n      var offsetHeight = lineDiv.clientHeight;\n      if (offsetHeight == cachedHeightFor) return cachedHeight;\n      cachedHeightFor = offsetHeight;\n      removeChildrenAndAdd(measure, measurePre.cloneNode(true));\n      cachedHeight = measure.firstChild.offsetHeight / 50 || 1;\n      removeChildren(measure);\n      return cachedHeight;\n    }\n    var cachedWidth, cachedWidthFor = 0;\n    function charWidth() {\n      if (scroller.clientWidth == cachedWidthFor) return cachedWidth;\n      cachedWidthFor = scroller.clientWidth;\n      var anchor = elt(\"span\", \"x\");\n      var pre = elt(\"pre\", [anchor]);\n      removeChildrenAndAdd(measure, pre);\n      return (cachedWidth = anchor.offsetWidth || 10);\n    }\n    function paddingTop() {return lineSpace.offsetTop;}\n    function paddingLeft() {return lineSpace.offsetLeft;}\n\n    function posFromMouse(e, liberal) {\n      var offW = eltOffset(scroller, true), x, y;\n      // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n      try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n      // This is a mess of a heuristic to try and determine whether a\n      // scroll-bar was clicked or not, and to return null if one was\n      // (and !liberal).\n      if (!liberal && (x - offW.left > scroller.clientWidth || y - offW.top > scroller.clientHeight))\n        return null;\n      var offL = eltOffset(lineSpace, true);\n      return coordsChar(x - offL.left, y - offL.top);\n    }\n    var detectingSelectAll;\n    function onContextMenu(e) {\n      var pos = posFromMouse(e), scrollPos = scrollbar.scrollTop;\n      if (!pos || opera) return; // Opera is difficult.\n      if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))\n        operation(setCursor)(pos.line, pos.ch);\n\n      var oldCSS = input.style.cssText;\n      inputDiv.style.position = \"absolute\";\n      input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; \" +\n        \"border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      focusInput();\n      resetInput(true);\n      // Adds \"Select all\" to context menu in FF\n      if (posEq(sel.from, sel.to)) input.value = prevInput = \" \";\n\n      function rehide() {\n        inputDiv.style.position = \"relative\";\n        input.style.cssText = oldCSS;\n        if (ie_lt9) scrollbar.scrollTop = scrollPos;\n        slowPoll();\n\n        // Try to detect the user choosing select-all \n        if (input.selectionStart != null) {\n          clearTimeout(detectingSelectAll);\n          var extval = input.value = \" \" + (posEq(sel.from, sel.to) ? \"\" : input.value), i = 0;\n          prevInput = \" \";\n          input.selectionStart = 1; input.selectionEnd = extval.length;\n          detectingSelectAll = setTimeout(function poll(){\n            if (prevInput == \" \" && input.selectionStart == 0)\n              operation(commands.selectAll)(instance);\n            else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n            else resetInput();\n          }, 200);\n        }\n      }\n\n      if (gecko) {\n        e_stop(e);\n        var mouseup = connect(window, \"mouseup\", function() {\n          mouseup();\n          setTimeout(rehide, 20);\n        }, true);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    }\n\n    // Cursor-blinking\n    function restartBlink() {\n      clearInterval(blinker);\n      var on = true;\n      cursor.style.visibility = \"\";\n      blinker = setInterval(function() {\n        cursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, options.cursorBlinkRate);\n    }\n\n    var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n    function matchBrackets(autoclear) {\n      var head = sel.inverted ? sel.from : sel.to, line = getLine(head.line), pos = head.ch - 1;\n      var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n      if (!match) return;\n      var ch = match.charAt(0), forward = match.charAt(1) == \">\", d = forward ? 1 : -1, st = line.styles;\n      for (var off = pos + 1, i = 0, e = st.length; i < e; i+=2)\n        if ((off -= st[i].length) <= 0) {var style = st[i+1]; break;}\n\n      var stack = [line.text.charAt(pos)], re = /[(){}[\\]]/;\n      function scan(line, from, to) {\n        if (!line.text) return;\n        var st = line.styles, pos = forward ? 0 : line.text.length - 1, cur;\n        for (var i = forward ? 0 : st.length - 2, e = forward ? st.length : -2; i != e; i += 2*d) {\n          var text = st[i];\n          if (st[i+1] != style) {pos += d * text.length; continue;}\n          for (var j = forward ? 0 : text.length - 1, te = forward ? text.length : -1; j != te; j += d, pos+=d) {\n            if (pos >= from && pos < to && re.test(cur = text.charAt(j))) {\n              var match = matching[cur];\n              if (match.charAt(1) == \">\" == forward) stack.push(cur);\n              else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};\n              else if (!stack.length) return {pos: pos, match: true};\n            }\n          }\n        }\n      }\n      for (var i = head.line, e = forward ? Math.min(i + 100, doc.size) : Math.max(-1, i - 100); i != e; i+=d) {\n        var line = getLine(i), first = i == head.line;\n        var found = scan(line, first && forward ? pos + 1 : 0, first && !forward ? pos : line.text.length);\n        if (found) break;\n      }\n      if (!found) found = {pos: null, match: false};\n      var style = found.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n      var one = markText({line: head.line, ch: pos}, {line: head.line, ch: pos+1}, style),\n          two = found.pos != null && markText({line: i, ch: found.pos}, {line: i, ch: found.pos + 1}, style);\n      var clear = operation(function(){one.clear(); two && two.clear();});\n      if (autoclear) setTimeout(clear, 800);\n      else bracketHighlighted = clear;\n    }\n\n    // Finds the line to start with when starting a parse. Tries to\n    // find a line with a stateAfter, so that it can start with a\n    // valid state. If that fails, it returns the line with the\n    // smallest indentation, which tends to need the least context to\n    // parse correctly.\n    function findStartLine(n) {\n      var minindent, minline;\n      for (var search = n, lim = n - 40; search > lim; --search) {\n        if (search == 0) return 0;\n        var line = getLine(search-1);\n        if (line.stateAfter) return search;\n        var indented = line.indentation(options.tabSize);\n        if (minline == null || minindent > indented) {\n          minline = search - 1;\n          minindent = indented;\n        }\n      }\n      return minline;\n    }\n    function getStateBefore(n) {\n      var pos = findStartLine(n), state = pos && getLine(pos-1).stateAfter;\n      if (!state) state = startState(mode);\n      else state = copyState(mode, state);\n      doc.iter(pos, n, function(line) {\n        line.process(mode, state, options.tabSize);\n        line.stateAfter = (pos == n - 1 || pos % 5 == 0) ? copyState(mode, state) : null;\n      });\n      return state;\n    }\n    function highlightWorker() {\n      if (frontier >= showingTo) return;\n      var end = +new Date + options.workTime, state = copyState(mode, getStateBefore(frontier));\n      var startFrontier = frontier;\n      doc.iter(frontier, showingTo, function(line) {\n        if (frontier >= showingFrom) { // Visible\n          line.highlight(mode, state, options.tabSize);\n          line.stateAfter = copyState(mode, state);\n        } else {\n          line.process(mode, state, options.tabSize);\n          line.stateAfter = frontier % 5 == 0 ? copyState(mode, state) : null;\n        }\n        ++frontier;\n        if (+new Date > end) {\n          startWorker(options.workDelay);\n          return true;\n        }\n      });\n      if (showingTo > startFrontier && frontier >= showingFrom)\n        operation(function() {changes.push({from: startFrontier, to: frontier});})();\n    }\n    function startWorker(time) {\n      if (frontier < showingTo)\n        highlight.set(time, highlightWorker);\n    }\n\n    // Operations are used to wrap changes in such a way that each\n    // change won't have to update the cursor and display (which would\n    // be awkward, slow, and error-prone), but instead updates are\n    // batched and then all combined and executed at once.\n    function startOperation() {\n      updateInput = userSelChange = textChanged = null;\n      changes = []; selectionChanged = false; callbacks = [];\n    }\n    function endOperation() {\n      if (updateMaxLine) computeMaxLength();\n      if (maxLineChanged && !options.lineWrapping) {\n        var cursorWidth = widthForcer.offsetWidth, left = measureLine(maxLine, maxLine.text.length).left;\n        if (!ie_lt8) {\n          widthForcer.style.left = left + \"px\";\n          lineSpace.style.minWidth = (left + cursorWidth) + \"px\";\n        }\n        maxLineChanged = false;\n      }\n      var newScrollPos, updated;\n      if (selectionChanged) {\n        var coords = calculateCursorCoords();\n        newScrollPos = calculateScrollPos(coords.x, coords.y, coords.x, coords.yBot);\n      }\n      if (changes.length || newScrollPos && newScrollPos.scrollTop != null)\n        updated = updateDisplay(changes, true, newScrollPos && newScrollPos.scrollTop);\n      if (!updated) {\n        if (selectionChanged) updateSelection();\n        if (gutterDirty) updateGutter();\n      }\n      if (newScrollPos) scrollCursorIntoView();\n      if (selectionChanged) restartBlink();\n\n      if (focused && (updateInput === true || (updateInput !== false && selectionChanged)))\n        resetInput(userSelChange);\n\n      if (selectionChanged && options.matchBrackets)\n        setTimeout(operation(function() {\n          if (bracketHighlighted) {bracketHighlighted(); bracketHighlighted = null;}\n          if (posEq(sel.from, sel.to)) matchBrackets(false);\n        }), 20);\n      var sc = selectionChanged, cbs = callbacks; // these can be reset by callbacks\n      if (textChanged && options.onChange && instance)\n        options.onChange(instance, textChanged);\n      if (sc && options.onCursorActivity)\n        options.onCursorActivity(instance);\n      for (var i = 0; i < cbs.length; ++i) cbs[i](instance);\n      if (updated && options.onUpdate) options.onUpdate(instance);\n    }\n    var nestedOperation = 0;\n    function operation(f) {\n      return function() {\n        if (!nestedOperation++) startOperation();\n        try {var result = f.apply(this, arguments);}\n        finally {if (!--nestedOperation) endOperation();}\n        return result;\n      };\n    }\n\n    function compoundChange(f) {\n      history.startCompound();\n      try { return f(); } finally { history.endCompound(); }\n    }\n\n    for (var ext in extensions)\n      if (extensions.propertyIsEnumerable(ext) &&\n          !instance.propertyIsEnumerable(ext))\n        instance[ext] = extensions[ext];\n    return instance;\n  } // (end of function CodeMirror)\n\n  // The default configuration options.\n  CodeMirror.defaults = {\n    value: \"\",\n    mode: null,\n    theme: \"default\",\n    indentUnit: 2,\n    indentWithTabs: false,\n    smartIndent: true,\n    tabSize: 4,\n    keyMap: \"default\",\n    extraKeys: null,\n    electricChars: true,\n    autoClearEmptyLines: false,\n    onKeyEvent: null,\n    onDragEvent: null,\n    lineWrapping: false,\n    lineNumbers: false,\n    gutter: false,\n    fixedGutter: false,\n    firstLineNumber: 1,\n    readOnly: false,\n    dragDrop: true,\n    onChange: null,\n    onCursorActivity: null,\n    onViewportChange: null,\n    onGutterClick: null,\n    onUpdate: null,\n    onFocus: null, onBlur: null, onScroll: null,\n    matchBrackets: false,\n    cursorBlinkRate: 530,\n    workTime: 100,\n    workDelay: 200,\n    pollInterval: 100,\n    undoDepth: 40,\n    tabindex: null,\n    autofocus: null,\n    lineNumberFormatter: function(integer) { return integer; }\n  };\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var win = /Win/.test(navigator.platform);\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n      spec = mimeModes[spec];\n    else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec))\n      return CodeMirror.resolveMode(\"application/xml\");\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    return mfactory(options, spec);\n  };\n  CodeMirror.listModes = function() {\n    var list = [];\n    for (var m in modes)\n      if (modes.propertyIsEnumerable(m)) list.push(m);\n    return list;\n  };\n  CodeMirror.listMIMEs = function() {\n    var list = [];\n    for (var m in mimeModes)\n      if (mimeModes.propertyIsEnumerable(m)) list.push({mime: m, mode: mimeModes[m]});\n    return list;\n  };\n\n  var extensions = CodeMirror.extensions = {};\n  CodeMirror.defineExtension = function(name, func) {\n    extensions[name] = func;\n  };\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection({line: 0, ch: 0}, {line: cm.lineCount() - 1});},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange(\"\", from, {line: from.line + 1, ch: 0});\n      else cm.replaceRange(\"\", from, sel ? to : {line: from.line});\n    },\n    deleteLine: function(cm) {var l = cm.getCursor().line; cm.replaceRange(\"\", {line: l, ch: 0}, {line: l});},\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.setCursor(0, 0, true);},\n    goDocEnd: function(cm) {cm.setSelection({line: cm.lineCount() - 1}, null, true);},\n    goLineStart: function(cm) {cm.setCursor(cm.getCursor().line, 0, true);},\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor();\n      var text = cm.getLine(cur.line), firstNonWS = Math.max(0, text.search(/\\S/));\n      cm.setCursor(cur.line, cur.ch <= firstNonWS && cur.ch ? 0 : firstNonWS, true);\n    },\n    goLineEnd: function(cm) {cm.setSelection({line: cm.getCursor().line}, null, true);},\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharLeft: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharRight: function(cm) {cm.deleteH(1, \"char\");},\n    delWordLeft: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordRight: function(cm) {cm.deleteH(1, \"word\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\", \"end\");},\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.replaceSelection(\"\\t\", \"end\");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        {line: cur.line, ch: cur.ch - 1}, {line: cur.line, ch: cur.ch + 1});\n    },\n    newlineAndIndent: function(cm) {\n      cm.replaceSelection(\"\\n\", \"end\");\n      cm.indentLine(cm.getCursor().line);\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharRight\", \"Backspace\": \"delCharLeft\", \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Alt-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goWordLeft\", \"Ctrl-Right\": \"goWordRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delWordLeft\", \"Ctrl-Delete\": \"delWordRight\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goWordLeft\",\n    \"Alt-Right\": \"goWordRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delWordLeft\",\n    \"Ctrl-Alt-Backspace\": \"delWordRight\", \"Alt-Delete\": \"delWordRight\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageUp\", \"Shift-Ctrl-V\": \"goPageDown\", \"Ctrl-D\": \"delCharRight\", \"Ctrl-H\": \"delCharLeft\",\n    \"Alt-D\": \"delWordRight\", \"Alt-Backspace\": \"delWordLeft\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n  function lookupKey(name, extraMap, map, handle, stop) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) {\n        if (stop) stop();\n        return true;\n      }\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) {\n        if (stop) stop();\n        return true;\n      }\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        if (lookup(fallthrough[i])) return true;\n      }\n      return false;\n    }\n    if (extraMap && lookup(extraMap)) return true;\n    return lookup(map);\n  }\n  function isModifierKey(event) {\n    var name = keyNames[e_prop(event, \"keyCode\")];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = instance.getValue();}\n    if (textarea.form) {\n      // Deplorable hack to make the submit method do the right thing.\n      var rmSubmit = connect(textarea.form, \"submit\", save, true);\n      if (typeof textarea.form.submit == \"function\") {\n        var realSubmit = textarea.form.submit;\n        textarea.form.submit = function wrappedSubmit() {\n          save();\n          textarea.form.submit = realSubmit;\n          textarea.form.submit();\n          textarea.form.submit = wrappedSubmit;\n        };\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var instance = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    instance.save = save;\n    instance.getTextArea = function() { return textarea; };\n    instance.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(instance.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        rmSubmit();\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return instance;\n  };\n\n  var gecko = /gecko\\/\\d{7}/i.test(navigator.userAgent);\n  var ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = /MSIE [1-7]\\b/.test(navigator.userAgent);\n  var ie_lt9 = /MSIE [1-8]\\b/.test(navigator.userAgent);\n  var quirksMode = ie && document.documentMode == 5;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 10\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n  }\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == 0;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {return countColumn(this.string, this.start, this.tabSize);},\n    indentation: function() {return countColumn(this.string, null, this.tabSize);},\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);}\n  };\n  CodeMirror.StringStream = StringStream;\n\n  function MarkedSpan(from, to, marker) {\n    this.from = from; this.to = to; this.marker = marker;\n  }\n\n  function getMarkedSpanFor(spans, marker, del) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) {\n        if (del) spans.splice(i, 1);\n        return span;\n      }\n    }\n  }\n\n  function markedSpansBefore(old, startCh, endCh) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || marker.type == \"bookmark\" && span.from == startCh && span.from != endCh) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || marker.type == \"bookmark\" && span.from == endCh) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function updateMarkedSpans(oldFirst, oldLast, startCh, endCh, newText) {\n    if (!oldFirst && !oldLast) return newText;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh);\n    var last = markedSpansAfter(oldLast, endCh);\n\n    // Next, merge those two ends\n    var sameLine = newText.length == 1, offset = lst(newText).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n\n    var newMarkers = [newHL(newText[0], first)];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = newText.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(newHL(newText[i+1], gapMarkers));\n      newMarkers.push(newHL(lst(newText), last));\n    }\n    return newMarkers;\n  }\n\n  // hl stands for history-line, a data structure that can be either a\n  // string (line without markers) or a {text, markedSpans} object.\n  function hlText(val) { return typeof val == \"string\" ? val : val.text; }\n  function hlSpans(val) { return typeof val == \"string\" ? null : val.markedSpans; }\n  function newHL(text, spans) { return spans ? {text: text, markedSpans: spans} : text; }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i) {\n      var lines = spans[i].marker.lines;\n      var ix = indexOf(lines, line);\n      lines.splice(ix, 1);\n    }\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      var marker = spans[i].marker.lines.push(line);\n    line.markedSpans = spans;\n  }\n\n  // When measuring the position of the end of a line, different\n  // browsers require different approaches. If an empty span is added,\n  // many browsers report bogus offsets. Of those, some (Webkit,\n  // recent IE) will accept a space without moving the whole span to\n  // the next line when wrapping it, others work with a zero-width\n  // space.\n  var eolSpanContent = \" \";\n  if (gecko || (ie && !ie_lt8)) eolSpanContent = \"\\u200b\";\n  else if (opera) eolSpanContent = \"\";\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  function Line(text, markedSpans) {\n    this.text = text;\n    this.height = 1;\n    attachMarkedSpans(this, markedSpans);\n  }\n  Line.prototype = {\n    update: function(text, markedSpans) {\n      this.text = text;\n      this.stateAfter = this.styles = null;\n      detachMarkedSpans(this);\n      attachMarkedSpans(this, markedSpans);\n    },\n    // Run the given mode's parser over a line, update the styles\n    // array, which contains alternating fragments of text and CSS\n    // classes.\n    highlight: function(mode, state, tabSize) {\n      var stream = new StringStream(this.text, tabSize), st = this.styles || (this.styles = []);\n      var pos = st.length = 0;\n      if (this.text == \"\" && mode.blankLine) mode.blankLine(state);\n      while (!stream.eol()) {\n        var style = mode.token(stream, state), substr = stream.current();\n        stream.start = stream.pos;\n        if (pos && st[pos-1] == style) {\n          st[pos-2] += substr;\n        } else if (substr) {\n          st[pos++] = substr; st[pos++] = style;\n        }\n        // Give up when line is ridiculously long\n        if (stream.pos > 5000) {\n          st[pos++] = this.text.slice(stream.pos); st[pos++] = null;\n          break;\n        }\n      }\n    },\n    process: function(mode, state, tabSize) {\n      var stream = new StringStream(this.text, tabSize);\n      if (this.text == \"\" && mode.blankLine) mode.blankLine(state);\n      while (!stream.eol() && stream.pos <= 5000) {\n        mode.token(stream, state);\n        stream.start = stream.pos;\n      }\n    },\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(mode, state, tabSize, ch) {\n      var txt = this.text, stream = new StringStream(txt, tabSize);\n      while (stream.pos < ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null,\n              state: state};\n    },\n    indentation: function(tabSize) {return countColumn(this.text, null, tabSize);},\n    // Produces an HTML fragment for the line, taking selection,\n    // marking, and highlighting into account.\n    getContent: function(tabSize, wrapAt, compensateForWrapping) {\n      var first = true, col = 0, specials = /[\\t\\u0000-\\u0019\\u200b\\u2028\\u2029\\uFEFF]/g;\n      var pre = elt(\"pre\");\n      function span_(html, text, style) {\n        if (!text) return;\n        // Work around a bug where, in some compat modes, IE ignores leading spaces\n        if (first && ie && text.charAt(0) == \" \") text = \"\\u00a0\" + text.slice(1);\n        first = false;\n        if (!specials.test(text)) {\n          col += text.length;\n          var content = document.createTextNode(text);\n        } else {\n          var content = document.createDocumentFragment(), pos = 0;\n          while (true) {\n            specials.lastIndex = pos;\n            var m = specials.exec(text);\n            var skipped = m ? m.index - pos : text.length - pos;\n            if (skipped) {\n              content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n              col += skipped;\n            }\n            if (!m) break;\n            pos += skipped + 1;\n            if (m[0] == \"\\t\") {\n              var tabWidth = tabSize - col % tabSize;\n              content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n              col += tabWidth;\n            } else {\n              var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n              token.title = \"\\\\u\" + m[0].charCodeAt(0).toString(16);\n              content.appendChild(token);\n              col += 1;\n            }\n          }\n        }\n        if (style) html.appendChild(elt(\"span\", [content], style));\n        else html.appendChild(content);\n      }\n      var span = span_;\n      if (wrapAt != null) {\n        var outPos = 0, anchor = pre.anchor = elt(\"span\");\n        span = function(html, text, style) {\n          var l = text.length;\n          if (wrapAt >= outPos && wrapAt < outPos + l) {\n            if (wrapAt > outPos) {\n              span_(html, text.slice(0, wrapAt - outPos), style);\n              // See comment at the definition of spanAffectsWrapping\n              if (compensateForWrapping) html.appendChild(elt(\"wbr\"));\n            }\n            html.appendChild(anchor);\n            var cut = wrapAt - outPos;\n            span_(anchor, opera ? text.slice(cut, cut + 1) : text.slice(cut), style);\n            if (opera) span_(html, text.slice(cut + 1), style);\n            wrapAt--;\n            outPos += l;\n          } else {\n            outPos += l;\n            span_(html, text, style);\n            if (outPos == wrapAt && outPos == len) {\n              setTextContent(anchor, eolSpanContent);\n              html.appendChild(anchor);\n            }\n            // Stop outputting HTML when gone sufficiently far beyond measure\n            else if (outPos > wrapAt + 10 && /\\s/.test(text)) span = function(){};\n          }\n        };\n      }\n\n      var st = this.styles, allText = this.text, marked = this.markedSpans;\n      var len = allText.length;\n      function styleToClass(style) {\n        if (!style) return null;\n        return \"cm-\" + style.replace(/ +/g, \" cm-\");\n      }\n      if (!allText && wrapAt == null) {\n        span(pre, \" \");\n      } else if (!marked || !marked.length) {\n        for (var i = 0, ch = 0; ch < len; i+=2) {\n          var str = st[i], style = st[i+1], l = str.length;\n          if (ch + l > len) str = str.slice(0, len - ch);\n          ch += l;\n          span(pre, str, styleToClass(style));\n        }\n      } else {\n        marked.sort(function(a, b) { return a.from - b.from; });\n        var pos = 0, i = 0, text = \"\", style, sg = 0;\n        var nextChange = marked[0].from || 0, marks = [], markpos = 0;\n        var advanceMarks = function() {\n          var m;\n          while (markpos < marked.length &&\n                 ((m = marked[markpos]).from == pos || m.from == null)) {\n            if (m.marker.style != null) marks.push(m);\n            ++markpos;\n          }\n          nextChange = markpos < marked.length ? marked[markpos].from : Infinity;\n          for (var i = 0; i < marks.length; ++i) {\n            var to = marks[i].to;\n            if (to == null) to = Infinity;\n            if (to == pos) marks.splice(i--, 1);\n            else nextChange = Math.min(to, nextChange);\n          }\n        };\n        var m = 0;\n        while (pos < len) {\n          if (nextChange == pos) advanceMarks();\n          var upto = Math.min(len, nextChange);\n          while (true) {\n            if (text) {\n              var end = pos + text.length;\n              var appliedStyle = style;\n              for (var j = 0; j < marks.length; ++j)\n                appliedStyle = (appliedStyle ? appliedStyle + \" \" : \"\") + marks[j].marker.style;\n              span(pre, end > upto ? text.slice(0, upto - pos) : text, appliedStyle);\n              if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n              pos = end;\n            }\n            text = st[i++]; style = styleToClass(st[i++]);\n          }\n        }\n      }\n      return pre;\n    },\n    cleanUp: function() {\n      this.parent = null;\n      detachMarkedSpans(this);\n    }\n  };\n\n  // Data structure that holds the sequence of lines.\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    remove: function(at, n, callbacks) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        line.cleanUp();\n        if (line.handlers)\n          for (var j = 0; j < line.handlers.length; ++j) callbacks.push(line.handlers[j]);\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertHeight: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    remove: function(at, n, callbacks) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.remove(at, rm, callbacks);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertHeight(at, lines, height);\n    },\n    insertHeight: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertHeight(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iter: function(from, to, op) { this.iterN(from, to - from, op); },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  function getLineAt(chunk, n) {\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0, e = chunk.children.length; ; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no;\n  }\n  function lineAtHeight(chunk, h) {\n    var n = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n  function heightAtLine(chunk, n) {\n    var h = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; continue outer; }\n        n -= sz;\n        h += child.height;\n      }\n      return h;\n    } while (!chunk.lines);\n    for (var i = 0; i < n; ++i) h += chunk.lines[i].height;\n    return h;\n  }\n\n  // The history object 'chunks' changes that are made close together\n  // and at almost the same time into bigger undoable units.\n  function History() {\n    this.time = 0;\n    this.done = []; this.undone = [];\n    this.compound = 0;\n    this.closed = false;\n  }\n  History.prototype = {\n    addChange: function(start, added, old) {\n      this.undone.length = 0;\n      var time = +new Date, cur = lst(this.done), last = cur && lst(cur);\n      var dtime = time - this.time;\n\n      if (this.compound && cur && !this.closed) {\n        cur.push({start: start, added: added, old: old});\n      } else if (dtime > 400 || !last || this.closed ||\n                 last.start > start + old.length || last.start + last.added < start) {\n        this.done.push([{start: start, added: added, old: old}]);\n        this.closed = false;\n      } else {\n        var startBefore = Math.max(0, last.start - start),\n            endAfter = Math.max(0, (start + old.length) - (last.start + last.added));\n        for (var i = startBefore; i > 0; --i) last.old.unshift(old[i - 1]);\n        for (var i = endAfter; i > 0; --i) last.old.push(old[old.length - i]);\n        if (startBefore) last.start = start;\n        last.added += added - (old.length - startBefore - endAfter);\n      }\n      this.time = time;\n    },\n    startCompound: function() {\n      if (!this.compound++) this.closed = true;\n    },\n    endCompound: function() {\n      if (!--this.compound) this.closed = true;\n    }\n  };\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // Allow 3rd-party code to override event properties by adding an override\n  // object to an event object.\n  function e_prop(e, prop) {\n    var overridden = e.override && e.override.hasOwnProperty(prop);\n    return overridden ? e.override[prop] : e[prop];\n  }\n\n  // Event handler registration. If disconnect is true, it'll return a\n  // function that unregisters the handler.\n  function connect(node, type, handler, disconnect) {\n    if (typeof node.addEventListener == \"function\") {\n      node.addEventListener(type, handler, false);\n      if (disconnect) return function() {node.removeEventListener(type, handler, false);};\n    } else {\n      var wrapHandler = function(event) {handler(event || window.event);};\n      node.attachEvent(\"on\" + type, wrapHandler);\n      if (disconnect) return function() {node.detachEvent(\"on\" + type, wrapHandler);};\n    }\n  }\n  CodeMirror.connect = connect;\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  // Feature-detect whether newlines in textareas are converted to \\r\\n\n  var lineSep = function () {\n    var te = elt(\"textarea\");\n    te.value = \"foo\\nbar\";\n    if (te.value.indexOf(\"\\r\") > -1) return \"\\r\\n\";\n    return \"\\n\";\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of regexps matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  var spanAffectsWrapping = /^$/; // Won't match any two-character string\n  if (gecko) spanAffectsWrapping = /$'/;\n  else if (safari) spanAffectsWrapping = /\\-[^ \\-?]|\\?[^ !'\\\"\\),.\\-\\/:;\\?\\]\\}]/;\n  else if (chrome) spanAffectsWrapping = /\\-[^ \\-\\.?]|\\?[^ \\-\\.?\\]\\}:;!'\\\"\\),\\/]|[\\.!\\\"#&%\\)*+,:;=>\\]|\\}~][\\(\\{\\[<]|\\$'/;\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = 0, n = 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n\n  function eltOffset(node, screen) {\n    // Take the parts of bounding client rect that we are interested in so we are able to edit if need be,\n    // since the returned value cannot be changed externally (they are kept in sync as the element moves within the page)\n    try { var box = node.getBoundingClientRect(); box = { top: box.top, left: box.left }; }\n    catch(e) { box = {top: 0, left: 0}; }\n    if (!screen) {\n      // Get the toplevel scroll, working around browser differences.\n      if (window.pageYOffset == null) {\n        var t = document.documentElement || document.body.parentNode;\n        if (t.scrollTop == null) t = document.body;\n        box.top += t.scrollTop; box.left += t.scrollLeft;\n      } else {\n        box.top += window.pageYOffset; box.left += window.pageXOffset;\n      }\n    }\n    return box;\n  }\n\n  function eltText(node) {\n    return node.textContent || node.innerText || node.nodeValue || \"\";\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else node.select();\n  }\n\n  // Operations on {line, ch} objects.\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function copyPos(x) {return {line: x.line, ch: x.ch};}\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n  function removeChildren(e) {\n    e.innerHTML = \"\";\n    return e;\n  }\n  function removeChildrenAndAdd(parent, e) {\n    removeChildren(parent).appendChild(e);\n  }\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = \"\";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  // Used to position the cursor after an undo/redo by finding the\n  // last edited character.\n  function editEnd(from, to) {\n    if (!to) return 0;\n    if (!from) return to.length;\n    for (var i = from.length, j = to.length; i >= 0 && j >= 0; --i, --j)\n      if (from.charAt(i) != to.charAt(j)) break;\n    return j + 1;\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch.toUpperCase() != ch.toLowerCase();\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 109: \"-\", 107: \"=\", 127: \"Delete\",\n                  186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n                  221: \"]\", 222: \"'\", 63276: \"PageUp\", 63277: \"PageDown\", 63275: \"End\", 63273: \"Home\",\n                  63234: \"Left\", 63232: \"Up\", 63235: \"Right\", 63233: \"Down\", 63302: \"Insert\", 63272: \"Delete\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  CodeMirror.version = \"2.33 +\";\n\n  return CodeMirror;\n})();\n\n//@ sourceURL=/node_modules/codemirror/lib/codemirror.js"
));

require.define("/node_modules/codemirror-embed/theme.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nfunction style(document, code) {\n  var node = document.createElement(\"style\")\n  node.innerHTML = code\n  document.head.appendChild(node)\n  return node\n}\n\nexports.style = style\n\n//@ sourceURL=/node_modules/codemirror-embed/theme.js"
));

require.define("/node_modules/codemirror/mode/javascript/javascript.js",Function(['require','module','exports','__dirname','__filename','process','global'],"CodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var jsonMode = parserConfig.json;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n    return {\n      \"if\": A, \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function nextUntilUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return false;\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return escaped;\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function jsTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, jsTokenString(ch));\n    else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch))\n      return ret(ch);\n    else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    }      \n    else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, jsTokenComment);\n      }\n      else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      }\n      else if (state.reAllowed) {\n        nextUntilUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      }\n      else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    }\n    else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"error\", \"error\");\n    }\n    else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n    else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function jsTokenString(quote) {\n    return function(stream, state) {\n      if (!nextUntilUnescaped(stream, quote))\n        state.tokenize = jsTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function jsTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = jsTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n  \n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      for (var v = state.localVars; v; v = v.next)\n        if (v.name == varname) return;\n      state.localVars = {name: varname, next: state.localVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function expecting(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type) {\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                      poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                         block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                        statement, poplex, popcontext);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(expression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n    \n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" && value == \"?\") return cont(expression, expect(\":\"), expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function commaSeparated(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef1, forspec2);\n    if (type == \";\") return pass(forspec2);\n    if (type == \"variable\") return cont(formaybein);\n    return pass(forspec2);\n  }\n  function formaybein(type, value) {\n    if (value == \"in\") return cont(expression);\n    return cont(maybeoperator, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\") return cont(expression);\n    return cont(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont();}\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: jsTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != '.';\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != jsTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \":{}\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\n\n//@ sourceURL=/node_modules/codemirror/mode/javascript/javascript.js"
));

require.define("/node_modules/codemirror/mode/htmlmixed/htmlmixed.js",Function(['require','module','exports','__dirname','__filename','process','global'],"CodeMirror.defineMode(\"htmlmixed\", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: \"xml\", htmlMode: true});\n  var jsMode = CodeMirror.getMode(config, \"javascript\");\n  var cssMode = CodeMirror.getMode(config, \"css\");\n\n  function html(stream, state) {\n    var style = htmlMode.token(stream, state.htmlState);\n    if (style == \"tag\" && stream.current() == \">\" && state.htmlState.context) {\n      if (/^script$/i.test(state.htmlState.context.tagName)) {\n        state.token = javascript;\n        state.localState = jsMode.startState(htmlMode.indent(state.htmlState, \"\"));\n        state.mode = \"javascript\";\n      }\n      else if (/^style$/i.test(state.htmlState.context.tagName)) {\n        state.token = css;\n        state.localState = cssMode.startState(htmlMode.indent(state.htmlState, \"\"));\n        state.mode = \"css\";\n      }\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur[0].length);\n      if (!stream.match(pat, false)) stream.match(cur[0]);\n    }\n    return style;\n  }\n  function javascript(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = null;\n      state.mode = \"html\";\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       jsMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = null;\n      state.mode = \"html\";\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localState: null, mode: \"html\", htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.token == css ? cssMode : jsMode, state.localState);\n      return {token: state.token, localState: local, mode: state.mode,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.token == html || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.token == javascript)\n        return jsMode.indent(state.localState, textAfter);\n      else\n        return cssMode.indent(state.localState, textAfter);\n    },\n\n    electricChars: \"/{}:\"\n  };\n}, \"xml\", \"javascript\", \"css\");\n\nCodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n\n//@ sourceURL=/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"
));

require.define("/node_modules/codemirror/mode/css/css.js",Function(['require','module','exports','__dirname','__filename','process','global'],"CodeMirror.defineMode(\"css\", function(config) {\n  var indentUnit = config.indentUnit, type;\n  \n  var atMediaTypes = keySet([\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ]);\n  \n  var atMediaFeatures = keySet([\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\"\n  ]);\n\n  var propertyKeywords = keySet([\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-iteration-count\",\n    \"animation-name\", \"animation-play-state\", \"animation-timing-function\",\n    \"appearance\", \"azimuth\", \"backface-visibility\", \"background\",\n    \"background-attachment\", \"background-clip\", \"background-color\",\n    \"background-image\", \"background-origin\", \"background-position\",\n    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\n    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\n    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\",\n    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\n    \"border-right-color\", \"border-right-style\", \"border-right-width\",\n    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\n    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\n    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\n    \"caption-side\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\n    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\n    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\n    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\n    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\n    \"dominant-baseline\", \"drop-initial-after-adjust\",\n    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\n    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\n    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\n    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\n    \"float\", \"float-offset\", \"font\", \"font-feature-settings\", \"font-family\",\n    \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\n    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\n    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\n    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\n    \"font-weight\", \"grid-cell\", \"grid-column\", \"grid-column-align\",\n    \"grid-column-sizing\", \"grid-column-span\", \"grid-columns\", \"grid-flow\",\n    \"grid-row\", \"grid-row-align\", \"grid-row-sizing\", \"grid-row-span\",\n    \"grid-rows\", \"grid-template\", \"hanging-punctuation\", \"height\", \"hyphens\",\n    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\n    \"inline-box-align\", \"justify-content\", \"left\", \"letter-spacing\",\n    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    \"marker-offset\", \"marks\", \"marquee-direction\", \"marquee-loop\",\n    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\n    \"max-width\", \"min-height\", \"min-width\", \"move-to\", \"nav-down\", \"nav-index\",\n    \"nav-left\", \"nav-right\", \"nav-up\", \"opacity\", \"order\", \"orphans\", \"outline\",\n    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\n    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\n    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\n    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\n    \"perspective-origin\", \"pitch\", \"pitch-range\", \"play-during\", \"position\",\n    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"rendering-intent\",\n    \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\", \"right\",\n    \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\n    \"ruby-position\", \"ruby-span\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\n    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\n    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\n    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\n    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\n    \"text-indent\", \"text-justify\", \"text-outline\", \"text-shadow\",\n    \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\n    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\n    \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\n    \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\n    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\n    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"word-break\",\n    \"word-spacing\", \"word-wrap\", \"z-index\"\n  ]);\n\n  var colorKeywords = keySet([\n    \"black\", \"silver\", \"gray\", \"white\", \"maroon\", \"red\", \"purple\", \"fuchsia\",\n    \"green\", \"lime\", \"olive\", \"yellow\", \"navy\", \"blue\", \"teal\", \"aqua\"\n  ]);\n  \n  var valueKeywords = keySet([\n    \"above\", \"absolute\", \"activeborder\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"auto\", \"avoid\", \"background\",\n    \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\", \"bengali\",\n    \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break-all\", \"break-word\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"compact\", \"condensed\", \"contain\", \"content\",\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\",\n    \"disc\", \"discard\", \"document\", \"dot-dash\", \"dot-dot-dash\", \"dotted\",\n    \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\",\n    \"ethiopic-halehame-tig\", \"ew-resize\", \"expanded\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"justify\", \"kannada\", \"katakana\", \"katakana-iroha\", \"khmer\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\",\n    \"line-through\", \"linear\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"malayalam\", \"match\",\n    \"media-controls-background\", \"media-current-time-display\",\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"navy\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"overlay\", \"overline\", \"padding\", \"padding-box\", \"painted\",\n    \"paused\", \"persian\", \"plus-darker\", \"plus-lighter\", \"pointer\", \"portrait\",\n    \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\", \"progress\", \"push-button\",\n    \"radio\", \"read-only\", \"read-write\", \"read-write-plaintext-only\", \"relative\",\n    \"repeat\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\", \"rgb\", \"rgba\",\n    \"ridge\", \"right\", \"round\", \"row-resize\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"scroll\", \"scrollbar\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n    \"single\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\",\n    \"sub\", \"subpixel-antialiased\", \"super\", \"sw-resize\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"white\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\", \"yellow\"\n  ]);\n\n  function keySet(array) { var keys = {}; for (var i = 0; i < array.length; ++i) keys[array[i]] = true; return keys; }\n  function ret(style, tp) {type = tp; return style;}\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == \"@\") {stream.eatWhile(/[\\w\\\\\\-]/); return ret(\"def\", stream.current());}\n    else if (ch == \"/\" && stream.eat(\"*\")) {\n      state.tokenize = tokenCComment;\n      return tokenCComment(stream, state);\n    }\n    else if (ch == \"<\" && stream.eat(\"!\")) {\n      state.tokenize = tokenSGMLComment;\n      return tokenSGMLComment(stream, state);\n    }\n    else if (ch == \"=\") ret(null, \"compare\");\n    else if ((ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) return ret(null, \"compare\");\n    else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    }\n    else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    }\n    else if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    }\n    else if (ch === \"-\") {\n      if (/\\d/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^[^-]+-/)) {\n        return ret(\"meta\", type);\n      }\n    }\n    else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    }\n    else if (ch == \".\" && stream.match(/^\\w+/)) {\n      return ret(\"qualifier\", type);\n    }\n    else if (ch == \":\") {\n      return ret(\"operator\", ch);\n    }\n    else if (/[;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    }\n    else {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"variable\");\n    }\n  }\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenSGMLComment(stream, state) {\n    var dashes = 0, ch;\n    while ((ch = stream.next()) != null) {\n      if (dashes >= 2 && ch == \">\") {\n        state.tokenize = tokenBase;\n        break;\n      }\n      dashes = (ch == \"-\") ? dashes + 1 : 0;\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped)\n          break;\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  return {\n    startState: function(base) {\n      return {tokenize: tokenBase,\n              baseIndent: base || 0,\n              stack: []};\n    },\n\n    token: function(stream, state) {\n      \n      // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)\n      // \n      // rule** or **ruleset:\n      // A selector + braces combo, or an at-rule.\n      // \n      // declaration block:\n      // A sequence of declarations.\n      // \n      // declaration:\n      // A property + colon + value combo.\n      // \n      // property value:\n      // The entire value of a property.\n      // \n      // component value:\n      // A single piece of a property value. Like the 5px in\n      // text-shadow: 0 0 5px blue;. Can also refer to things that are\n      // multiple terms, like the 1-4 terms that make up the background-size\n      // portion of the background shorthand.\n      // \n      // term:\n      // The basic unit of author-facing CSS, like a single number (5),\n      // dimension (5px), string (\"foo\"), or function. Officially defined\n      //  by the CSS 2.1 grammar (look for the 'term' production)\n      // \n      // \n      // simple selector:\n      // A single atomic selector, like a type selector, an attr selector, a\n      // class selector, etc.\n      // \n      // compound selector:\n      // One or more simple selectors without a combinator. div.example is\n      // compound, div > .example is not.\n      // \n      // complex selector:\n      // One or more compound selectors chained with combinators.\n      // \n      // combinator:\n      // The parts of selectors that express relationships. There are four\n      // currently - the space (descendant combinator), the greater-than\n      // bracket (child combinator), the plus sign (next sibling combinator),\n      // and the tilda (following sibling combinator).\n      // \n      // sequence of selectors:\n      // One or more of the named type of selector chained with commas.\n\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n\n      // Changing style returned based on context\n      var context = state.stack[state.stack.length-1];\n      if (style == \"property\") {\n        if (context == \"propertyValue\"){\n          if (valueKeywords[stream.current()]) {\n            style = \"string-2\";\n          } else if (colorKeywords[stream.current()]) {\n            style = \"keyword\";\n          } else {\n            style = \"variable-2\";\n          }\n        } else if (context == \"rule\") {\n          if (!propertyKeywords[stream.current()]) {\n            style += \" error\";\n          }\n        } else if (!context || context == \"@media{\") {\n          style = \"tag\";\n        } else if (context == \"@media\") {\n          if (atMediaTypes[stream.current()]) {\n            style = \"attribute\"; // Known attribute\n          } else if (/^(only|not)$/i.test(stream.current())) {\n            style = \"keyword\";\n          } else if (stream.current().toLowerCase() == \"and\") {\n            style = \"error\"; // \"and\" is only allowed in @mediaType\n          } else if (atMediaFeatures[stream.current()]) {\n            style = \"error\"; // Known property, should be in @mediaType(\n          } else {\n            // Unknown, expecting keyword or attribute, assuming attribute\n            style = \"attribute error\";\n          }\n        } else if (context == \"@mediaType\") {\n          if (atMediaTypes[stream.current()]) {\n            style = \"attribute\";\n          } else if (stream.current().toLowerCase() == \"and\") {\n            style = \"operator\";\n          } else if (/^(only|not)$/i.test(stream.current())) {\n            style = \"error\"; // Only allowed in @media\n          } else if (atMediaFeatures[stream.current()]) {\n            style = \"error\"; // Known property, should be in parentheses\n          } else {\n            // Unknown attribute or property, but expecting property (preceded\n            // by \"and\"). Should be in parentheses\n            style = \"error\";\n          }\n        } else if (context == \"@mediaType(\") {\n          if (propertyKeywords[stream.current()]) {\n            // do nothing, remains \"property\"\n          } else if (atMediaTypes[stream.current()]) {\n            style = \"error\"; // Known property, should be in parentheses\n          } else if (stream.current().toLowerCase() == \"and\") {\n            style = \"operator\";\n          } else if (/^(only|not)$/i.test(stream.current())) {\n            style = \"error\"; // Only allowed in @media\n          } else {\n            style += \" error\";\n          }\n        } else {\n          style = \"error\";\n        }\n      } else if (style == \"atom\") {\n        if(!context || context == \"@media{\") {\n          style = \"builtin\";\n        } else if (context == \"propertyValue\") {\n          if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n            style += \" error\";\n          }\n        } else {\n          style = \"error\";\n        }\n      } else if (context == \"@media\" && type == \"{\") {\n        style = \"error\";\n      }\n\n      // Push/pop context stack\n      if (type == \"{\") {\n        if (context == \"@media\" || context == \"@mediaType\") {\n          state.stack.pop();\n          state.stack[state.stack.length-1] = \"@media{\";\n        }\n        else state.stack.push(\"rule\");\n      }\n      else if (type == \"}\") {\n        state.stack.pop();\n        if (context == \"propertyValue\") state.stack.pop();\n      }\n      else if (type == \"@media\") state.stack.push(\"@media\");\n      else if (context == \"@media\" && /\\b(keyword|attribute)\\b/.test(style))\n        state.stack.push(\"@mediaType\");\n      else if (context == \"@mediaType\" && stream.current() == \",\") state.stack.pop();\n      else if (context == \"@mediaType\" && type == \"(\") state.stack.push(\"@mediaType(\");\n      else if (context == \"@mediaType(\" && type == \")\") state.stack.pop();\n      else if (context == \"rule\" && type == \":\") state.stack.push(\"propertyValue\");\n      else if (context == \"propertyValue\" && type == \";\") state.stack.pop();\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var n = state.stack.length;\n      if (/^\\}/.test(textAfter))\n        n -= state.stack[state.stack.length-1] == \"propertyValue\" ? 2 : 1;\n      return state.baseIndent + n * indentUnit;\n    },\n\n    electricChars: \"}\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/css\", \"css\");\n\n//@ sourceURL=/node_modules/codemirror/mode/css/css.js"
));

require.define("/node_modules/codemirror-embed/theme/codemirror.css.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports=\".CodeMirror {\\n  line-height: 1em;\\n  font-family: monospace;\\n\\n  /* Necessary so the scrollbar can be absolutely positioned within the wrapper on Lion. */\\n  position: relative;\\n  /* This prevents unwanted scrollbars from showing up on the body and wrapper in IE. */\\n  overflow: hidden;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: auto;\\n  height: 300px;\\n  /* This is needed to prevent an IE[67] bug where the scrolled content\\n     is visible outside of the scrolling box. */\\n  position: relative;\\n  outline: none;\\n}\\n\\n/* Vertical scrollbar */\\n.CodeMirror-scrollbar {\\n  position: absolute;\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n  z-index: 5;\\n}\\n.CodeMirror-scrollbar-inner {\\n  /* This needs to have a nonzero width in order for the scrollbar to appear\\n     in Firefox and IE9. */\\n  width: 1px;\\n}\\n.CodeMirror-scrollbar.cm-sb-overlap {\\n  /* Ensure that the scrollbar appears in Lion, and that it overlaps the content\\n     rather than sitting to the right of it. */\\n  position: absolute;\\n  z-index: 1;\\n  float: none;\\n  right: 0;\\n  min-width: 12px;\\n}\\n.CodeMirror-scrollbar.cm-sb-nonoverlap {\\n  min-width: 12px;\\n}\\n.CodeMirror-scrollbar.cm-sb-ie7 {\\n  min-width: 18px;\\n}\\n\\n.CodeMirror-gutter {\\n  position: absolute; left: 0; top: 0;\\n  z-index: 10;\\n  background-color: #f7f7f7;\\n  border-right: 1px solid #eee;\\n  min-width: 2em;\\n  height: 100%;\\n}\\n.CodeMirror-gutter-text {\\n  color: #aaa;\\n  text-align: right;\\n  padding: .4em .2em .4em .4em;\\n  white-space: pre !important;\\n  cursor: default;\\n}\\n.CodeMirror-lines {\\n  padding: .4em;\\n  white-space: pre;\\n  cursor: text;\\n}\\n\\n.CodeMirror pre {\\n  -moz-border-radius: 0;\\n  -webkit-border-radius: 0;\\n  -o-border-radius: 0;\\n  border-radius: 0;\\n  border-width: 0; margin: 0; padding: 0; background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  padding: 0; margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n}\\n\\n.CodeMirror-wrap pre {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n.CodeMirror-wrap .CodeMirror-scroll {\\n  overflow-x: hidden;\\n}\\n\\n.CodeMirror textarea {\\n  outline: none !important;\\n}\\n\\n.CodeMirror pre.CodeMirror-cursor {\\n  z-index: 10;\\n  position: absolute;\\n  visibility: hidden;\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n.cm-keymap-fat-cursor pre.CodeMirror-cursor {\\n  width: auto;\\n  border: 0;\\n  background: transparent;\\n  background: rgba(0, 200, 0, .4);\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#6600c800, endColorstr=#4c00c800);\\n}\\n/* Kludge to turn off filter in ie9+, which also accepts rgba */\\n.cm-keymap-fat-cursor pre.CodeMirror-cursor:not(#nonsense_id) {\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\\n}\\n.CodeMirror pre.CodeMirror-cursor.CodeMirror-overwrite {}\\n.CodeMirror-focused pre.CodeMirror-cursor {\\n  visibility: visible;\\n}\\n\\ndiv.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused div.CodeMirror-selected { background: #d7d4f0; }\\n\\n.CodeMirror-searching {\\n  background: #ffa;\\n  background: rgba(255, 255, 0, .4);\\n}\\n\\n/* Default theme */\\n\\n.cm-s-default span.cm-keyword {color: #708;}\\n.cm-s-default span.cm-atom {color: #219;}\\n.cm-s-default span.cm-number {color: #164;}\\n.cm-s-default span.cm-def {color: #00f;}\\n.cm-s-default span.cm-variable {color: black;}\\n.cm-s-default span.cm-variable-2 {color: #05a;}\\n.cm-s-default span.cm-variable-3 {color: #085;}\\n.cm-s-default span.cm-property {color: black;}\\n.cm-s-default span.cm-operator {color: black;}\\n.cm-s-default span.cm-comment {color: #a50;}\\n.cm-s-default span.cm-string {color: #a11;}\\n.cm-s-default span.cm-string-2 {color: #f50;}\\n.cm-s-default span.cm-meta {color: #555;}\\n.cm-s-default span.cm-error {color: #f00;}\\n.cm-s-default span.cm-qualifier {color: #555;}\\n.cm-s-default span.cm-builtin {color: #30a;}\\n.cm-s-default span.cm-bracket {color: #cc7;}\\n.cm-s-default span.cm-tag {color: #170;}\\n.cm-s-default span.cm-attribute {color: #00c;}\\n.cm-s-default span.cm-header {color: blue;}\\n.cm-s-default span.cm-quote {color: #090;}\\n.cm-s-default span.cm-hr {color: #999;}\\n.cm-s-default span.cm-link {color: #00c;}\\n\\nspan.cm-header, span.cm-strong {font-weight: bold;}\\nspan.cm-em {font-style: italic;}\\nspan.cm-emstrong {font-style: italic; font-weight: bold;}\\nspan.cm-link {text-decoration: underline;}\\n\\nspan.cm-invalidchar {color: #f00;}\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\\n\\n@media print {\\n\\n  /* Hide the cursor when printing */\\n  .CodeMirror pre.CodeMirror-cursor {\\n    visibility: hidden;\\n  }\\n\\n}\"\n\n//@ sourceURL=/node_modules/codemirror-embed/theme/codemirror.css.js"
));

require.define("/main.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Editor = require(\"codemirror-embed\")\nvar style = require(\"codemirror-embed/theme\").style\nvar jsmode = require(\"codemirror/mode/javascript/javascript\")\nvar htmlmode = require(\"codemirror/mode/htmlmixed/htmlmixed\")\nvar cssmode = require(\"codemirror/mode/css/css\")\n\n//var solarized = require(\"codemirror-embed/theme/solarized.css.js\")\nvar baseStyle = require(\"codemirror-embed/theme/codemirror.css.js\")\n\n//var matchbrackets = require(\"codemirror/addon/edit/matchbrackets\")\n\nstyle(document, baseStyle)\n//style(document, solarized)\n\nfunction send(data) {\n  var event = document.createEvent(\"CustomEvent\")\n  event.initCustomEvent(\"request\", false, true, data)\n  window.dispatchEvent(event)\n}\n\nvar editor = Editor(document.body, {\n  matchBrackets: true,\n  electricChars: true,\n  autofocus: true,\n  //theme: \"solarized dark\",\n  value: \"// Addon pad\\n\",\n  lineNumbers: true,\n  mode: \"javascript\",\n  onChange: function(editor, change) {\n    send({ change: change, code: editor.getValue() })\n  },\n  extraKeys: {\n    \"Tab\": function indent(editor) {\n      if (!editor.getOption(\"indentWithTabs\")) {\n        var size = editor.getOption(\"indentUnit\")\n        var indentation = Array(size + 1).join(\" \")\n        editor.replaceSelection(indentation, \"end\")\n      }\n    }\n  }\n})\n\nglobal.editor = editor\nmodule.exports = editor\n\n//@ sourceURL=/main.js"
));
require("/main.js");
})();

